"use strict";(self.webpackChunklayotto_docusaurus=self.webpackChunklayotto_docusaurus||[]).push([[2433],{2986:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=r(4848),t=r(8453);const a={},s="Layotto Source Parsing \u2014 Processing RPC requests",i={permalink:"/layotto/en-US/blog/code/layotto-rpc",editUrl:"https://github.com/mosn/layotto/edit/main/docs/i18n/en-US/docusaurus-plugin-content-blog/code/layotto-rpc/index.md",source:"@site/i18n/en-US/docusaurus-plugin-content-blog/code/layotto-rpc/index.md",title:"Layotto Source Parsing \u2014 Processing RPC requests",description:"This paper is based on the Dubbo Json RPC as an example of the Layotto RPC processing.",date:"2024-07-08T06:55:24.000Z",tags:[],readingTime:20.73,hasTruncateMarker:!1,authors:[],frontMatter:{},unlisted:!1,prevItem:{title:"Source Parsing 7 Layer Traffic Governance, Interface Limit",permalink:"/layotto/en-US/blog/code/flowcontrol/flowcontrol_code_analyze"},nextItem:{title:"Source parsing layotto startup process",permalink:"/layotto/en-US/blog/code/start_process/start_process"}},c={authorsImageUrls:[]},l=[{value:"General description",id:"general-description",level:2},{value:"Source analysis",id:"source-analysis",level:2},{value:"0x00 Layotto initialize RPC",id:"0x00-layotto-initialize-rpc",level:3},{value:"0x01 Dubbo-go-sample client request",id:"0x01-dubbo-go-sample-client-request",level:3},{value:"0x02 Mosn EventLoop Reader Processing Request Data",id:"0x02-mosn-eventloop-reader-processing-request-data",level:3},{value:"0x03 Grpc Sever processed requests as NetworkFilter",id:"0x03-grpc-sever-processed-requests-as-networkfilter",level:3},{value:"0x04 Layotto send RPC requests and write to local virtual connections",id:"0x04-layotto-send-rpc-requests-and-write-to-local-virtual-connections",level:3},{value:"0x05 Mosn read Remote and execute Filter and proxy forwarding",id:"0x05-mosn-read-remote-and-execute-filter-and-proxy-forwarding",level:3},{value:"0x06 Dubbo-go-sample server received request return response",id:"0x06-dubbo-go-sample-server-received-request-return-response",level:3},{value:"0x07 Mosn framework handles responses and writes back to Remote Virtual Connection",id:"0x07-mosn-framework-handles-responses-and-writes-back-to-remote-virtual-connection",level:3},{value:"0x08 Layotto receive RPC responses and read Local Virtual Connection",id:"0x08-layotto-receive-rpc-responses-and-read-local-virtual-connection",level:3},{value:"0x09 Grpc Sever processed data frames returned to clients",id:"0x09-grpc-sever-processed-data-frames-returned-to-clients",level:3},{value:"0x10 dubbo-go-sample customer received response",id:"0x10-dubbo-go-sample-customer-received-response",level:3},{value:"Summary",id:"summary",level:2}];function p(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"This paper is based on the Dubbo Json RPC as an example of the Layotto RPC processing."}),"\n",(0,o.jsxs)(n.p,{children:["by\uff1a",(0,o.jsx)(n.a,{href:"https://github.com/rayowang",children:"Wang Zhilong"})," | 21April 2022"]}),"\n"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#overview",children:"overview"})}),"\n",(0,o.jsxs)(n.li,{children:["[source analysis](#source analysis)","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#_0x00-layotto-initializ-rpc",children:"0x00 Layotto initialize RPC"})}),"\n",(0,o.jsx)(n.li,{children:"[0x01 Dubbo-go-sample client to request request] (#_0x01-dubbo-go-sample-client-request request)"}),"\n",(0,o.jsx)(n.li,{children:"[0x02 Mosn EventLoop Reader Processing Request Data](#_0x02-mosn-eventloop-read processing request)"}),"\n",(0,o.jsx)(n.li,{children:"[0x03 Grpc Sever as NetworkFilter to process requests](#_0x03-grpc-sever as -networkfilter-process requests)"}),"\n",(0,o.jsx)(n.li,{children:"[0x04 Layotto send RPC requests and write to Local Virtual Connections](#_0x04-layotto -rpc-request and write to -local-virtual connection)"}),"\n",(0,o.jsx)(n.li,{children:"[0x05 Mosn reads Remote and executes Filter and Proxy Forwarding](#_0x05-mosn-read-remote-remote--and --filter-and proxy forward)"}),"\n",(0,o.jsx)(n.li,{children:"[0x06 Dubbo-go-sample server received response to request return] (#_0x06-dubbo-go-sample-server-received response return)"}),"\n",(0,o.jsx)(n.li,{children:"[0x07 Mosn Framework handles response and writes back to Remote Virtual Connections](#_0x07-mosn-Framework handles response and -remote-virtual connection)"}),"\n",(0,o.jsx)(n.li,{children:"[0x08 Layotto receive RPC responses and read Local Virtual Connections](#_0x08-layotto-receive-rpc-response and read -local-virtual connection)"}),"\n",(0,o.jsx)(n.li,{children:"[0x09 Grpc Sever processed data frames returned to client](#_0x09-grpc-sever processed frame returned to client)"}),"\n",(0,o.jsx)(n.li,{children:"[0x10 Dubbo-go-sample client receiving response](#_0x10-dubbo-go-sample-client-receiving response)"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#summary",children:"summary"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"general-description",children:"General description"}),"\n",(0,o.jsx)(n.p,{children:"Layotto has a clear and rich semiconductor API as a distributed prototype collection of prototype language distinguished from the network proxy service Mesh and using standard protocol API, which is part of the RPC API.Through RPC API app developers can interact with local Layotto instances of applications that also use the Sidecar architecture, thereby indirectly calling different service methods and using built-in capabilities to perform distributive tracking and diagnosis, traffic control, error handling, secure links, etc.and Layotto is based on the Grpc handler design, using the X-Protocol protocol for secure and reliable communications, except for Http/Grpc communications with other services.As shown in the following code, the RPC API interface is in line with Dapr and is available for RPC calls through the Grpc interface InvokeService."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"type DaprClient interface {\n    // Invokes a method on a remote Dapr app.\n    InvokeService(ctx context.Context, in *InvokeServiceRequest, opts ...grpc.CallOption) (*v1.InvokeResponse, error)\n    ...\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"source-analysis",children:"Source analysis"}),"\n",(0,o.jsx)(n.p,{children:"For ease of understanding, from outside to inside, from inside to outside, from flow to source code, that is, from Client, through one layer of logic to the Server receiving a return response to requests, from another layer of return to client, and from one layer of analysis of Layotto RPC processes, split into 10 steps.Also, since the content of Gypc Client and Server handshakes and interactions is not the focus of this paper, the analysis is relatively brief and the other steps are relatively detailed and one can move directly from the directory to the corresponding step depending on his or her case."}),"\n",(0,o.jsx)(n.p,{children:"Note\uff1abased on commit hash\uff1a1d2bed68c3b2372c34a12aeed41be125a4fdd15a"}),"\n",(0,o.jsx)(n.h3,{id:"0x00-layotto-initialize-rpc",children:"0x00 Layotto initialize RPC"}),"\n",(0,o.jsx)(n.p,{children:"Layotto starts the process involves a large number of processes in which only the initialization of the process related to RPC and described below is analyzed because Layotto is based on Mosn and is therefore starting from the Main function, urfave/cli library calls Mosn StageManager Mos, thus initializing GrpcServer in Mosn NetworkFilter as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'mosn.io/mosn/pkg/stagemanager.(*StageManager).runInitStage at stage_manager.go\n=>\nmosn.io/mosn/pkg/mosn.(*Mosn).initServer at mosn.go\n=>\nmosn.io/mosn/pkg/filter/network/grpc.(*grpcServerFilterFactory).Init at factory.go\n=>\nmosn.io/mosn/pkg/filter/network/grpc.(*Handler).New at factory.go\n// \u65b0\u5efa\u4e00\u4e2a\u5e26\u6709\u5730\u5740\u7684 Grpc \u670d\u52a1\u5668\u3002\u540c\u4e00\u4e2a\u5730\u5740\u8fd4\u56de\u540c\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u53ea\u80fd\u542f\u52a8\u4e00\u6b21\nfunc (s *Handler) New(addr string, conf json.RawMessage, options ...grpc.ServerOption) (*registerServerWrapper, error) {\n    s.mutex.Lock()\n    defer s.mutex.Unlock()\n    sw, ok := s.servers[addr]\n    if ok {\n        return sw, nil\n    }\n    ln, err := NewListener(addr)\n    if err != nil {\n        log.DefaultLogger.Errorf("create a listener failed: %v", err)\n        return nil, err\n    }\n    // \u8c03\u7528 NewRuntimeGrpcServer\n    srv, err := s.f(conf, options...)\n    if err != nil {\n        log.DefaultLogger.Errorf("create a registered server failed: %v", err)\n        return nil, err\n    }\n    sw = &registerServerWrapper{\n        server: srv,\n        ln:     ln,\n    }\n    s.servers[addr] = sw\n    return sw, nil\n}\n=\nmain.NewRunvtimeGrpcServer at main.go\n=>\nmosn.io/layotto/pkg/runtime.(*MosnRuntime).initRuntime at runtime.go\n=>\nmosn.io/layotto/pkg/runtime.(*MosnRuntime).initRpcs at runtime.go\n=>\nmosn.io/layotto/components/rpc/invoker/mosn.(*mosnInvoker).Init at mosninvoker.go\nfunc (m *mosnInvoker) Init(conf rpc.RpcConfig) error {\n    var config mosnConfig\n    if err := json.Unmarshal(conf.Config, &config); err != nil {\n        return err\n    }\n\n    // \u521d\u59cb\u5316 RPC \u8c03\u7528\u524d\u7684 Filter\n    for _, before := range config.Before {\n        m.cb.AddBeforeInvoke(before)\n    }\n\n    // \u521d\u59cb\u5316 RPC \u8c03\u7528\u540e\u7684 Filter\n    for _, after := range config.After {\n        m.cb.AddAfterInvoke(after)\n    }\n\n    if len(config.Channel) == 0 {\n        return errors.New("missing channel config")\n    }\n\n    // \u521d\u59cb\u5316\u4e0e Mosn \u901a\u4fe1\u4f7f\u7528\u7684\u901a\u9053\u3001\u534f\u8bae\u53ca\u5bf9\u5e94\u7aef\u53e3\n    channel, err := channel.GetChannel(config.Channel[0])\n    if err != nil {\n        return err\n    }\n    m.channel = channel\n    return nil\n}\n...\n// \u5b8c\u6210\u4e00\u4e9b\u5217\u521d\u59cb\u5316\u540e\u5728 grpcServerFilter \u4e2d\u542f\u52a8 Grpc Server\nmosn.io/mosn/pkg/filter/network/grpc.(*grpcServerFilterFactory).Init at factory.go\nfunc (f *grpcServerFilterFactory) Init(param interface{}) error {\n    ...\n    opts := []grpc.ServerOption{\n        grpc.UnaryInterceptor(f.UnaryInterceptorFilter),\n        grpc.StreamInterceptor(f.StreamInterceptorFilter),\n    }\n    // \u7ecf\u8fc7\u4e0a\u8ff0\u521d\u59cb\u5316\uff0c\u5b8c\u6210 Grpc registerServerWrapper \u7684\u521d\u59cb\u5316\n    sw, err := f.handler.New(addr, f.config.GrpcConfig, opts...)\n    if err != nil {\n        return err\n    }\n    // \u542f\u52a8 Grpc sever\n    sw.Start(f.config.GracefulStopTimeout)\n    f.server = sw\n    log.DefaultLogger.Debugf("grpc server filter initialized success")\n    return nil\n}\n...\n// StageManager \u5728 runInitStage \u4e4b\u540e\u8fdb\u5165 runStartStage \u542f\u52a8 Mosn\nfunc (stm *StageManager) runStartStage() {\n    st := time.Now()\n    stm.SetState(Starting)\n    for _, f := range stm.startupStages {\n        f(stm.app)\n    }\n\n    stm.wg.Add(1)\n    // \u5728\u6240\u6709\u542f\u52a8\u9636\u6bb5\u5b8c\u6210\u540e\u542f\u52a8 Mosn\n    stm.app.Start()\n    ...\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"0x01-dubbo-go-sample-client-request",children:"0x01 Dubbo-go-sample client request"}),"\n",(0,o.jsxs)(n.p,{children:["Follow the example of ",(0,o.jsx)(n.a,{href:"https://mosn.io/layotto/en-US/docs/start/rpc/dub_json_rpc",children:"Dubbo Json Rpc Example"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:'go un demo/rpc/dubbo_json_rpc/dub_json_client/client.go -d \'{"jsonrpc": "2.0", "method":"GetUser", "params":["A003"],"id":9527}\'\n'})}),"\n",(0,o.jsx)(n.p,{children:"Use Layotto for App Gypc API InvokeService initiate RPC calls, data filling and connecting processes leading to the dispatch of data to Layotto via SendMsg in Grpc clientStream, as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'\nfunc main() {\n    data := flag.String("d", `{"jsonrpc":"2.0","method":"GetUser","params":["A003"],"id":9527}`, "-d")\n    flag.Parse()\n    \n    conn, err := grpc.Dial("localhost:34904", grpc.WithInsecure())\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    cli := runtimev1pb.NewRuntimeClient(conn)\n    ctx, cancel := context.WithCancel(context.TODO())\n    defer cancel()\n    // \u901a\u8fc7 Grpc \u63a5\u53e3 InvokeService \u8fdb\u884c RPC \u8c03\u7528\n    resp, err := cli.InvokeService(\n        ctx,\n       // \u4f7f\u7528 runtimev1pb.InvokeServiceRequest \u53d1\u8d77 Grpc \u8bf7\u6c42\n        &runtimev1pb.InvokeServiceRequest{\n           // \u8981\u8bf7\u6c42\u7684 server \u63a5\u53e3 ID\n           Id: "org.apache.dubbo.samples.UserProvider",\n            Message: &runtimev1pb.CommonInvokeRequest{\n               // \u8981\u8bf7\u6c42\u7684\u63a5\u53e3\u5bf9\u5e94\u7684\u65b9\u6cd5\u540d\n                Method:        "GetUser",\n                ContentType:   "",\n                Data:          &anypb.Any{Value: []byte(*data)},\n                HttpExtension: &runtimev1pb.HTTPExtension{Verb: runtimev1pb.HTTPExtension_POST},\n            },\n        },\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(resp.Data.GetValue()))\n}\n=>\nmosn.io/layotto/spec/proto/runtime/v1.(*runtimeClient).InvokeService at runtime.pb.go\n=>\ngoogle.golang.org/grpc.(*ClientConn).Invoke at call.go\n=>\ngoogle.golang.org/grpc.(*clientStream).SendMsg at stream.go\n=>\ngoogle.golang.org/grpc.(*csAttempt).sendMsg at stream.go\n=>\ngoogle.golang.org/grpc/internal/transport.(*http2Client).Write at http2_client.go\n'})}),"\n",(0,o.jsx)(n.h3,{id:"0x02-mosn-eventloop-reader-processing-request-data",children:"0x02 Mosn EventLoop Reader Processing Request Data"}),"\n",(0,o.jsx)(n.p,{children:"The kernel from Layotto mentioned above is a mock-up of Mosn, so when network connection data arrives, it will first be read and written at the L4 network level in Mosn as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"mosn.io/mosn/pkg/network.(*listener).accept at listener.go\n=>\nmosn.io/mosn/pkg/server.(*activeListener).OnAccept at handler.go\n=>\nmosn.io/mosn/pkg/server.(*activeRawConn).ContinueFilterChain at handler.go\n=>\nmosn.io/mosn/pkg/server.(*activeListener).newConnection at handler.go\n=>\nmosn.io/mosn/pkg/network.(*connection).Start at connection.go\n=>\nmosn.io/mosn/pkg/network.(*connection).startRWLoop at connection.go\nfunc (c *connection) startRWLoop(lctx context.Context) {\n    c.internalLoopStarted = true\n\n    utils.GoWithRecover(func() {\n       // \u8bfb\u534f\u7a0b\n        c.startReadLoop()\n    }, func(r interface{}) {\n        c.Close(api.NoFlush, api.LocalClose)\n    })\n\n    if c.checkUseWriteLoop() {\n        c.useWriteLoop = true\n        utils.GoWithRecover(func() {\n           // \u5199\u534f\u7a0b\n            c.startWriteLoop()\n        }, func(r interface{}) {\n            c.Close(api.NoFlush, api.LocalClose)\n        })\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"In the startRWLoop method, we can see that two separate protocols will be opened to deal with reading and writing operations on the connection: startReadLoop and startWriteLoop; the following streams will be made in startReadLoop; the data read at the network level will be handled by the filterManager filter chain, as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'mosn.io/mosn/pkg/network.(*connection).doRead at connection.go\n=>\nmosn.io/mosn/pkg/network.(*connection).onRead at connection.go\n=>\nmosn.io/mosn/pkg/network.(*filterManager).OnRead at filtermanager.go\n=>\nmosn.io/mosn/pkg/network.(*filterManager).onContinueReading at filtermanager.go\nfunc (fm *filterManager) onContinueReading(filter *activeReadFilter) {\n    var index int\n    var uf *activeReadFilter\n\n    if filter != nil {\n        index = filter.index + 1\n    }\n\n    // filterManager\u904d\u5386\u8fc7\u6ee4\u5668\u8fdb\u884c\u6570\u636e\u5904\u7406\n    for ; index < len(fm.upstreamFilters); index++ {\n        uf = fm.upstreamFilters[index]\n        uf.index = index\n        // \u5bf9\u6ca1\u6709\u521d\u59cb\u5316\u7684\u8fc7\u6ee4\u5668\u8c03\u7528\u5176\u521d\u59cb\u5316\u65b9\u6cd5 OnNewConnection\uff0c\u672c\u4f8b\u4e3afunc (f *grpcFilter) OnNewConnection() api.FilterStatus\uff08\u5411 Listener \u53d1\u9001 grpc \u8fde\u63a5\u4ee5\u5524\u9192 Listener \u7684 Accept\uff09\n        if !uf.initialized {\n            uf.initialized = true\n\n            status := uf.filter.OnNewConnection()\n\n            if status == api.Stop {\n                return\n            }\n        }\n\n        buf := fm.conn.GetReadBuffer()\n\n        if buf != nil && buf.Len() > 0 {\n           // \u901a\u77e5\u76f8\u5e94\u8fc7\u6ee4\u5668\u5904\u7406\n            status := uf.filter.OnData(buf)\n\n            if status == api.Stop {\n                return\n            }\n        }\n    }\n}\n=>\nmosn.io/mosn/pkg/filter/network/grpc.(*grpcFilter).OnData at filter.go\n=>\nmosn.io/mosn/pkg/filter/network/grpc.(*grpcFilter).dispatch at filter.go\nfunc (f *grpcFilter) dispatch(buf buffer.IoBuffer) {\n    if log.DefaultLogger.GetLogLevel() >= log.DEBUG {\n        log.DefaultLogger.Debugf("grpc get datas: %d", buf.Len())\n    }\n    // \u53d1\u9001\u6570\u636e\u5524\u9192\u8fde\u63a5\u8bfb\u53d6\n    f.conn.Send(buf)\n    if log.DefaultLogger.GetLogLevel() >= log.DEBUG {\n        log.DefaultLogger.Debugf("read dispatch finished")\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"0x03-grpc-sever-processed-requests-as-networkfilter",children:"0x03 Grpc Sever processed requests as NetworkFilter"}),"\n",(0,o.jsx)(n.p,{children:"Reading data from the original connection in the first phase will enter the Grpc Serve handling, the Serve method will use the net.Listener listener, each time a new protocol is launched to handle the new connection (handleRawCon), and a RPC call based on Http2-based transport will be set out below."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"google.golang.org/grpc.(*Server).handleRawConn at server.go\nfunc (s *Server) handleRawConn(lisAddr string, rawConn net.Conn) {\n    // \u6821\u9a8c\u670d\u52a1\u72b6\u6001\n    if s.quit.HasFired() {\n        rawConn.Close()\n        return\n    }\n    rawConn.SetDeadline(time.Now().Add(s.opts.connectionTimeout))\n    conn, authInfo, err := s.useTransportAuthenticator(rawConn)\n    if err != nil {\n       ...\n    }\n    // HTTP2 \u63e1\u624b\uff0c\u521b\u5efa Http2Server \u4e0e\u5ba2\u6237\u7aef\u4ea4\u6362\u5e27\u7684\u521d\u59cb\u5316\u4fe1\u606f\uff0c\u5e27\u548c\u7a97\u53e3\u5927\u5c0f\u7b49\n    st := s.newHTTP2Transport(conn, authInfo)\n    if st == nil {\n        return\n    }\n\n    rawConn.SetDeadline(time.Time{})\n    if !s.addConn(lisAddr, st) {\n        return\n    }\n    // \u521b\u5efa\u4e00\u4e2a\u534f\u7a0b\u8fdb\u884c\u6d41\u5904\u7406\n    go func() {\n        s.serveStreams(st)\n        s.removeConn(lisAddr, st)\n    }()\n    ...\n}\n=>\ngoogle.golang.org/grpc.(*Server).serveStreams at server.go\n=>\ngoogle.golang.org/grpc.(*Server).handleStream at server.go\nfunc (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) {\n    // \u627e\u5230\u5230\u9700\u8981\u8c03\u7528\u7684 FullMethod\uff0c\u6b64\u4f8b\u4e3a spec.proto.runtime.v1.Runtime/InvokeService\n    sm := stream.Method()\n    if sm != \"\" && sm[0] == '/' {\n        sm = sm[1:]\n    }\n    ...\n    service := sm[:pos]\n    method := sm[pos+1:]\n\n    // \u4ece\u6ce8\u518c\u7684 service \u5217\u8868\u4e2d\u627e\u5230\u5bf9\u5e94 serviceInfo \u5bf9\u8c61\n    srv, knownService := s.services[service]\n    if knownService {\n        // \u6839\u636e\u65b9\u6cd5\u540d\u627e\u5230\u5355\u5411\u8bf7\u6c42\u7684 md\u2014\u2014MethodDesc\uff0c\u6b64 demo \u4e3a mosn.io/layotto/spec/proto/runtime/v1._Runtime_InvokeService_Handler\n        if md, ok := srv.methods[method]; ok {\n            s.processUnaryRPC(t, stream, srv, md, trInfo)\n            return\n        }\n        // \u6d41\u5f0f\u8bf7\u6c42\n        if sd, ok := srv.streams[method]; ok {\n            s.processStreamingRPC(t, stream, srv, sd, trInfo)\n            return\n        }\n    }\n    ...\n=>\ngoogle.golang.org/grpc.(*Server).processUnaryRPC at server.go\n=>\nmosn.io/layotto/spec/proto/runtime/v1._Runtime_InvokeService_Handler at runtime.pb.go\n=>\ngoogle.golang.org/grpc.chainUnaryServerInterceptors at server.go\n=>\n// \u670d\u52a1\u7aef\u5355\u5411\u8c03\u7528\u62e6\u622a\u5668\uff0c\u7528\u4ee5\u8c03\u7528 Mosn \u7684 streamfilter\nmosn.io/mosn/pkg/filter/network/grpc.(*grpcServerFilterFactory).UnaryInterceptorFilter at factory.go\n=>\ngoogle.golang.org/grpc.getChainUnaryHandler at server.go\n// \u9012\u5f52\u751f\u6210\u94fe\u5f0fUnaryHandler\nfunc getChainUnaryHandler(interceptors []UnaryServerInterceptor, curr int, info *UnaryServerInfo, finalHandler UnaryHandler) UnaryHandler {\n    if curr == len(interceptors)-1 {\n        return finalHandler\n    }\n\n    return func(ctx context.Context, req interface{}) (interface{}, error) {\n       // finalHandler\u5c31\u662fmosn.io/layotto/spec/proto/runtime/v1._Runtime_InvokeService_Handler\n        return interceptors[curr+1](ctx, req, info, getChainUnaryHandler(interceptors, curr+1, info, finalHandler))\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"0x04-layotto-send-rpc-requests-and-write-to-local-virtual-connections",children:"0x04 Layotto send RPC requests and write to local virtual connections"}),"\n",(0,o.jsx)(n.p,{children:"The 0x03 process follows Runtime_InvokeService_Handler, converted from the GRPC Default API to Dapr API, entering the light RPC framework provided by Layotto in Mosn, as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'mosn.io/layotto/spec/proto/runtime/v1._Runtime_InvokeService_Handler at runtime.pb.go\n=>\nmosn.io/layotto/pkg/grpc/default_api.(*api).InvokeService at api.go\n=>\nmosn.io/layotto/pkg/grpc/dapr.(*daprGrpcAPI).InvokeService at dapr_api.go\n=>\nmosn.io/layotto/components/rpc/invoker/mosn.(*mosnInvoker).Invoke at mosninvoker.go\n// \u8bf7\u6c42 Mosn \u5e95\u5ea7\u548c\u8fd4\u56de\u54cd\u5e94\nfunc (m *mosnInvoker) Invoke(ctx context.Context, req *rpc.RPCRequest) (resp *rpc.RPCResponse, err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf("[runtime][rpc]mosn invoker panic: %v", r)\n            log.DefaultLogger.Errorf("%v", err)\n        }\n    }()\n\n    // 1. \u5982\u679c\u8d85\u65f6\u65f6\u95f4\u4e3a 0\uff0c\u8bbe\u7f6e\u9ed8\u8ba4 3000ms \u8d85\u65f6\n    if req.Timeout == 0 {\n        req.Timeout = 3000\n    }\n    req.Ctx = ctx\n    log.DefaultLogger.Debugf("[runtime][rpc]request %+v", req)\n    // 2. \u89e6\u53d1\u8bf7\u6c42\u6267\u884c\u524d\u7684\u81ea\u5b9a\u4e49\u903b\u8f91\n    req, err = m.cb.BeforeInvoke(req)\n    if err != nil {\n        log.DefaultLogger.Errorf("[runtime][rpc]before filter error %s", err.Error())\n        return nil, err\n    }\n    // 3. \u6838\u5fc3\u8c03\u7528\uff0c\u4e0b\u6587\u4f1a\u8fdb\u884c\u8be6\u7ec6\u5206\u6790\n    resp, err = m.channel.Do(req)\n    if err != nil {\n        log.DefaultLogger.Errorf("[runtime][rpc]error %s", err.Error())\n        return nil, err\n    }\n    resp.Ctx = req.Ctx\n    // 4. \u89e6\u53d1\u8bf7\u6c42\u8fd4\u56de\u540e\u7684\u81ea\u5b9a\u4e49\u903b\u8f91\n    resp, err = m.cb.AfterInvoke(resp)\n    if err != nil {\n        log.DefaultLogger.Errorf("[runtime][rpc]after filter error %s", err.Error())\n    }\n    return resp, err\n}\n=>\nmosn.io/layotto/components/rpc/invoker/mosn/channel.(*httpChannel).Do at httpchannel.go\nfunc (h *httpChannel) Do(req *rpc.RPCRequest) (*rpc.RPCResponse, error) {\n    // 1. \u4f7f\u7528\u4e0a\u4e00\u9636\u6bb5\u8bbe\u7f6e\u7684\u9ed8\u8ba4\u8d85\u65f6\u8bbe\u7f6e context \u8d85\u65f6\n    timeout := time.Duration(req.Timeout) * time.Millisecond\n    ctx, cancel := context.WithTimeout(req.Ctx, timeout)\n    defer cancel()\n\n    // 2. \u521b\u5efa\u8fde\u63a5\u5f97\u5230\uff0c\u542f\u52a8 readloop \u534f\u7a0b\u8fdb\u884c Layotto \u548c Mosn \u7684\u8bfb\u5199\u4ea4\u4e92\uff08\u5177\u4f53\u89c1\u4e0b\u6587\u5206\u6790\uff09\n    conn, err := h.pool.Get(ctx)\n    if err != nil {\n        return nil, err\n    }\n    \n    // 3. \u8bbe\u7f6e\u6570\u636e\u5199\u5165\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4\n    hstate := conn.state.(*hstate)\n    deadline, _ := ctx.Deadline()\n    if err = conn.SetWriteDeadline(deadline); err != nil {\n        hstate.close()\n        h.pool.Put(conn, true)\n        return nil, common.Error(common.UnavailebleCode, err.Error())\n    }\n    // 4. \u56e0\u4e3a\u521d\u59cb\u5316\u65f6\u914d\u7f6e\u7684 Layotto \u4e0e Mosn \u4ea4\u4e92\u4f7f\u7528\u7684\u662f Http \u534f\u8bae\uff0c\u6240\u4ee5\u8fd9\u91cc\u4f1a\u6784\u9020 Http \u8bf7\u6c42\n    httpReq := h.constructReq(req)\n    defer fasthttp.ReleaseRequest(httpReq)\n\n    // \u501f\u52a9 fasthttp \u8bf7\u6c42\u4f53\u5199\u5165\u865a\u62df\u8fde\u63a5\n    if _, err = httpReq.WriteTo(conn); err != nil {\n        hstate.close()\n        h.pool.Put(conn, true)\n        return nil, common.Error(common.UnavailebleCode, err.Error())\n    }\n\n    // 5. \u6784\u9020 fasthttp.Response \u7ed3\u6784\u4f53\u8bfb\u53d6\u548c\u89e3\u6790 hstate \u7684\u8fd4\u56de\uff0c\u5e76\u8bbe\u7f6e\u8bfb\u53d6\u8d85\u65f6\u65f6\u95f4\n    httpResp := &fasthttp.Response{}\n    hstate.reader.SetReadDeadline(deadline)\n\n    // \u5728 Mosn \u6570\u636e\u8fd4\u56de\u524d\u8fd9\u91cc\u4f1a\u963b\u585e\uff0creadloop \u534f\u7a0b\u8bfb\u53d6 Mosn \u8fd4\u56de\u7684\u6570\u636e\u4e4b\u540e\u6d41\u7a0b\u89c1\u4e0b\u8ff0 0x08 \u9636\u6bb5\n    if err = httpResp.Read(bufio.NewReader(hstate.reader)); err != nil {\n        hstate.close()\n        h.pool.Put(conn, true)\n        return nil, common.Error(common.UnavailebleCode, err.Error())\n    }\n    h.pool.Put(conn, false)\n    ...\n}\n=>\nmosn.io/layotto/components/rpc/invoker/mosn/channel.(*connPool).Get at connpool.go\n// Get is get wrapConn by context.Context\nfunc (p *connPool) Get(ctx context.Context) (*wrapConn, error) {\n    if err := p.waitTurn(ctx); err != nil {\n        return nil, err\n    }\n\n    p.mu.Lock()\n    // 1. \u4ece\u8fde\u63a5\u6c60\u83b7\u53d6\u8fde\u63a5\n    if ele := p.free.Front(); ele != nil {\n        p.free.Remove(ele)\n        p.mu.Unlock()\n        wc := ele.Value.(*wrapConn)\n        if !wc.isClose() {\n            return wc, nil\n        }\n    } else {\n        p.mu.Unlock()\n    }\n\n    // 2. \u521b\u5efa\u65b0\u7684\u8fde\u63a5\n    c, err := p.dialFunc()\n    if err != nil {\n        p.freeTurn()\n        return nil, err\n    }\n    wc := &wrapConn{Conn: c}\n    if p.stateFunc != nil {\n        wc.state = p.stateFunc()\n    }\n    // 3. \u542f\u52a8 readloop \u72ec\u7acb\u534f\u7a0b\u8bfb\u53d6 Mosn \u8fd4\u56de\u7684\u6570\u636e\n    if p.onDataFunc != nil {\n        utils.GoWithRecover(func() {\n            p.readloop(wc)\n        }, nil)\n    }\n    return wc, nil\n}\n=>\n'})}),"\n",(0,o.jsx)(n.p,{children:"The creation of a new connection in the second step above requires attention by calling dialFunc func() in the protocol that initialized the init phase (net.Conn, error), because the configuration interacted with Mosn with Http protocols, this is newHttpChanel, which is currently supported by the Bolt, Dubbo et al."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'mosn.io/layotto/components/rpc/invoker/mosn/channel.newHttpChannel at httpchannel.go\n// newHttpChannel is used to create rpc.Channel according to ChannelConfig\nfunc newHttpChannel(config ChannelConfig) (rpc.Channel, error) {\n    hc := &httpChannel{}\n    // \u4e3a\u51cf\u5c11\u8fde\u63a5\u521b\u5efa\u5f00\u9500\u7684\u8fde\u63a5\u6c60\uff0c\u5b9a\u4e49\u5728 mosn.io/layotto/components/rpc/invoker/mosn/channel/connpool.go\n    hc.pool = newConnPool(\n        config.Size,\n        // dialFunc\n        func() (net.Conn, error) {\n            _, _, err := net.SplitHostPort(config.Listener)\n            if err == nil {\n                return net.Dial("tcp", config.Listener)\n            }\n           //\u521b\u5efa\u4e00\u5bf9\u865a\u62df\u8fde\u63a5(net.Pipe)\uff0cLayotto \u6301\u6709 local\uff0cMosn \u6301\u6709 remote, Layotto \u5411 local \u5199\u5165\uff0cMosn \u4f1a\u6536\u5230\u6570\u636e, Mosn \u4ece remote\u8bfb\u53d6\uff0c\u6267\u884c filter \u903b\u8f91\u5e76\u8fdb\u884c\u4ee3\u7406\u8f6c\u53d1\uff0c\u518d\u5c06\u54cd\u5e94\u5199\u5230 remote ,\u6700\u540e Layotto \u4ece remote \u8bfb\u53d6\uff0c\u83b7\u5f97\u54cd\u5e94\n            local, remote := net.Pipe()\n            localTcpConn := &fakeTcpConn{c: local}\n            remoteTcpConn := &fakeTcpConn{c: remote}\n           // acceptFunc \u662f\u5b9a\u4e49\u5728 mosn.io/layotto/components/rpc/invoker/mosn/channel.go \u4e2d\u7684\u95ed\u5305\uff0c\u95ed\u5305\u4e2d\u76d1\u542c\u4e86 remote \u865a\u62df\u8fde\u63a5\n            if err := acceptFunc(remoteTcpConn, config.Listener); err != nil {\n                return nil, err\n            }\n            // the goroutine model is:\n            // request goroutine ---\x3e  localTcpConn ---\x3e mosn\n            //        ^                                        |\n            //        |                                        |\n            //        |                                        |\n            //         hstate <-- readloop goroutine     <------\n            return localTcpConn, nil\n        },\n        // stateFunc\n        func() interface{} {\n            // hstate \u662f readloop \u534f\u7a0b\u4e0e request \u534f\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053\uff0c\u662f\u4e00\u5bf9\u8bfb\u5199 net.Conn\uff0c\u8bf7\u6c42\u534f\u7a0b\u4ece reader net.Conn \u4e2d\u8bfb\u6570\u636e\uff0creadloop \u534f\u7a0b\u5e8f\u5f80 writer net.Conn \u5199\u6570\u636e\n            s := &hstate{}\n            s.reader, s.writer = net.Pipe()\n            return s\n        },\n        hc.onData,\n        hc.cleanup,\n    )\n    return hc, nil\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"0x05-mosn-read-remote-and-execute-filter-and-proxy-forwarding",children:"0x05 Mosn read Remote and execute Filter and proxy forwarding"}),"\n",(0,o.jsx)(n.p,{children:"(1) Similar to 0x02, filtermanager executes the filter processing phase where proxy forwarding is made in proxy with the following code."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"...\nmosn.io/mosn/pkg/network.(*filterManager).onContinueReading at filtermanager.go\n=>\nmosn.io/mosn/pkg/proxy.(*proxy).OnData at proxy.go\nfunc (p *proxy) OnData(buf buffer.IoBuffer) api.FilterStatus {\n    if p.fallback {\n        return api.Continue\n    }\n\n    if p.serverStreamConn == nil {\n        ...\n        p.serverStreamConn = stream.CreateServerStreamConnection(p.context, proto, p.readCallbacks.Connection(), p)\n    }\n    //\u628a\u6570\u636e\u5206\u53d1\u5230\u5bf9\u5e94\u534f\u8bae\u7684\u89e3\u7801\u5668\uff0c\u5728\u8fd9\u91cc\u56e0\u4e3a\u662f POST /org.apache.dubbo.samples.UserProvider HTTP/1.1\uff0c\u6240\u4ee5\u662f mosn.io/mosn/pkg/stream/http.(*serverStreamConnection).serve at stream.go\n    p.serverStreamConn.Dispatch(buf)\n\n    return api.Stop\n}\n=>\n"})}),"\n",(0,o.jsx)(n.p,{children:"(2) ServerStreamConnection.serve listens and handles requests to downstream OnReceive, as described below."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"mosn.io/mosn/pkg/stream/http.(*serverStream).handleRequest at stream.go\nfunc (s *serverStream) handleRequest(ctx context.Context) {\n    if s.request != nil {\n        // set non-header info in request-line, like method, uri\n        injectCtxVarFromProtocolHeaders(ctx, s.header, s.request.URI())\n        hasData := true\n        if len(s.request.Body()) == 0 {\n            hasData = false\n        }\n\n        if hasData {\n           //\u5728\u6b64\u8fdb\u5165 downstream OnReceive\n            s.receiver.OnReceive(s.ctx, s.header, buffer.NewIoBufferBytes(s.request.Body()), nil)\n        } else {\n            s.receiver.OnReceive(s.ctx, s.header, nil, nil)\n        }\n    }\n}\n=>\nmosn.io/mosn/pkg/proxy.(*downStream).OnReceive at downstream.go\nfunc (s *downStream) OnReceive(ctx context.Context, headers types.HeaderMap, data types.IoBuffer, trailers types.HeaderMap) {\n    ...\n    var task = func() {\n        ...\n\n        phase := types.InitPhase\n        for i := 0; i < 10; i++ {\n            s.cleanNotify()\n\n            phase = s.receive(s.context, id, phase)\n            ...\n            }\n        }\n    }\n\n    if s.proxy.serverStreamConn.EnableWorkerPool() {\n        if s.proxy.workerpool != nil {\n            // use the worker pool for current proxy\n            s.proxy.workerpool.Schedule(task)\n        } else {\n            // use the global shared worker pool\n            pool.ScheduleAuto(task)\n        }\n        return\n    }\n\n    task()\n    return\n\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"(3) The above ScheduleAuto schedule, after processing the reveive of downstream Stream, processing upstam Request, as well as an application with an application from the network layer, eventually sending data from connection.Write and entering WaitNotify phases, as detailed below."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'mosn.io/mosn/pkg/sync.(*workerPool).ScheduleAuto at workerpool.go\n=>\nmosn.io/mosn/pkg/sync.(*workerPool).spawnWorker at workerpool.go\n=>\nmosn.io/mosn/pkg/proxy.(*downStream).receive at downstream.go\n=>\nInitPhase=>DownFilter=>MatchRoute=>DownFilterAfterRoute=>ChooseHost=>DownFilterAfterChooseHost=>DownRecvHeader=>DownRecvData\n=>\nmosn.io/mosn/pkg/proxy.(*downStream).receiveData at downstream.go\n=>\nmosn.io/mosn/pkg/proxy.(*upstreamRequest).appendData at upstream.go\n=>\nmosn.io/mosn/pkg/stream/http.(*clientStream).doSend at stream.go\n=>\ngithub.com/valyala/fasthttp.(*Request).WriteTo at http.go\n=>\nmosn.io/mosn/pkg/stream/http.(*streamConnection).Write at stream.go\n>\nmosn.io/mosn/pkg/network.(*connection).Write at connection.go\n=>\nmosn.io/mosn/pkg/proxy.(*downStream).receive at downstream.go\nfunc (s *downStream) receive(ctx context.Context, id uint32, phase types.Phase) types.Phase {\n    for i := 0; i <= int(types.End-types.InitPhase); i++ {\n        s.phase = phase\n        \n        switch phase {\n        ...\n        case types.WaitNotify:\n            s.printPhaseInfo(phase, id)\n            if p, err := s.waitNotify(id); err != nil {\n                return p\n            }\n        \n            if log.Proxy.GetLogLevel() >= log.DEBUG {\n            \tlog.Proxy.Debugf(s.context, "[proxy] [downstream] OnReceive send downstream response %+v", s.downstreamRespHeaders)\n            }\n        ...\n} \n=>\nfunc (s *downStream) waitNotify(id uint32) (phase types.Phase, err error) {\n    if atomic.LoadUint32(&s.ID) != id {\n        return types.End, types.ErrExit\n    }\n\n\tif log.Proxy.GetLogLevel() >= log.DEBUG {\n\t\tlog.Proxy.Debugf(s.context, "[proxy] [downstream] waitNotify begin %p, proxyId = %d", s, s.ID)\n\t}\n\tselect {\n\t// \u963b\u585e\u7b49\u5f85\n\tcase <-s.notify:\n\t}\n\treturn s.processError(id)\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"0x06-dubbo-go-sample-server-received-request-return-response",children:"0x06 Dubbo-go-sample server received request return response"}),"\n",(0,o.jsx)(n.p,{children:"Here is a dubo-go-sample server handling, leave it now, post log messages and check the source code by interested classes."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'[2022-04-18/21:03:03:18 github.com/apache/dub-go-samples/rpc/jsonrpc/go-server/pkg.(*UserProvider2).GetUser: user_provider2.go: 53] userID: "A003"\n[2022-04-18/21:03:18 github.com/apache/dub-go-samples/rpc/jsonrpc/go-server/pkg. (*UserProvider2).GetUser: user_provider2.go: 56] rsp:&pkg.User{ID:"113", Name:"Moorse", Age:30, sex:0, Birth:703391943, Sex:"MAN"MAN"}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"0x07-mosn-framework-handles-responses-and-writes-back-to-remote-virtual-connection",children:"0x07 Mosn framework handles responses and writes back to Remote Virtual Connection"}),"\n",(0,o.jsx)(n.p,{children:"After the third phase of 0x05 above, the response logic goes into the UpRecvData phase of the reveive cycle phase through a series of final response writing back to the remote virtual connection at 0x04, as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'mosn.io/mosn/pkg/proxy.(*downStream).receive at downstream.go\nfunc (s *downStream) waitNotify(id uint32) (phase types.Phase, err error) {\n    if atomic.LoadUint32(&s.ID) != id {\n        return types.End, types.ErrExit\n    }\n    \n    if log.Proxy.GetLogLevel() >= log.DEBUG {\n        log.Proxy.Debugf(s.context, "[proxy] [downstream] waitNotify begin %p, proxyId = %d", s, s.ID)\n    }\n    // \u8fd4\u56de\u54cd\u5e94\n    select {\n    case <-s.notify:\n    }\n    return s.processError(id)\n}\n=>\nUpFilter\n=>\nUpRecvHeader\n=>\nfunc (s *downStream) receive(ctx context.Context, id uint32, phase types.Phase) types.Phase {\n    for i := 0; i <= int(types.End-types.InitPhase); i++ {\n        s.phase = phase\n\n        switch phase {\n        ...\n        case types.UpRecvData:\n            if s.downstreamRespDataBuf != nil {\n            \ts.printPhaseInfo(phase, id)\n            \ts.upstreamRequest.receiveData(s.downstreamRespTrailers == nil)\n                if p, err := s.processError(id); err != nil {\n              \t   return p\n              }\n           }\n        ...\n}\n=>\nmosn.io/mosn/pkg/proxy.(*upstreamRequest).receiveData at upstream.go\n=>\nmosn.io/mosn/pkg/proxy.(*downStream).onUpstreamData at downstream.go\n=>\nmosn.io/mosn/pkg/proxy.(*downStream).appendData at downstream.go\n=>\nmosn.io/mosn/pkg/stream/http.(*serverStream).AppendData at stream.go\n=>\nmosn.io/mosn/pkg/stream/http.(*serverStream).endStream at stream.go\n=>\nmosn.io/mosn/pkg/stream/http.(*serverStream).doSend at stream.go\n=>\ngithub.com/valyala/fasthttp.(*Response).WriteTo at http.go\n=>\ngithub.com/valyala/fasthttp.writeBufio at http.go\n=>\ngithub.com/valyala/fasthttp.(*statsWriter).Write at http.go\n=>\nmosn.io/mosn/pkg/stream/http.(*streamConnection).Write at stream.go\n'})}),"\n",(0,o.jsx)(n.h3,{id:"0x08-layotto-receive-rpc-responses-and-read-local-virtual-connection",children:"0x08 Layotto receive RPC responses and read Local Virtual Connection"}),"\n",(0,o.jsx)(n.p,{children:"Readloop Reading IO, activated by 0x04 above, is activated from connection read data from Mosn and then forwarded to the hstate pipe to return to the request process, as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'mosn.io/layotto/components/rpc/invoker/mosn/channel.(*connPool).readloop at connpool.go\n// readloop is loop to read connected then exec onDataFunc\nfunc (p *connPool) readloop(c *wrapConn) {\n    var err error\n\n    defer func() {\n        c.close()\n        if p.cleanupFunc != nil {\n            p.cleanupFunc(c, err)\n        }\n    }()\n\n    c.buf = buffer.NewIoBuffer(defaultBufSize)\n    for {\n        // \u4ece\u8fde\u63a5\u8bfb\u53d6\u6570\u636e\n        n, readErr := c.buf.ReadOnce(c)\n        if readErr != nil {\n            err = readErr\n            if readErr == io.EOF {\n                log.DefaultLogger.Debugf("[runtime][rpc]connpool readloop err: %s", readErr.Error())\n            } else {\n                log.DefaultLogger.Errorf("[runtime][rpc]connpool readloop err: %s", readErr.Error())\n            }\n        }\n\n        if n > 0 {\n            // \u5728onDataFunc \u59d4\u6258\u7ed9 hstate \u5904\u7406\u6570\u636e\n            if onDataErr := p.onDataFunc(c); onDataErr != nil {\n                err = onDataErr\n                log.DefaultLogger.Errorf("[runtime][rpc]connpool onData err: %s", onDataErr.Error())\n            }\n        }\n\n        if err != nil {\n            break\n        }\n\n        if c.buf != nil && c.buf.Len() == 0 && c.buf.Cap() > maxBufSize {\n            c.buf.Free()\n            c.buf.Alloc(defaultBufSize)\n        }\n    }\n}\n=>\nmosn.io/layotto/components/rpc/invoker/mosn/channel.(*httpChannel).onData at httpchannel.go\n=>\nmosn.io/layotto/components/rpc/invoker/mosn/channel.(*hstate).onData at httpchannel.go\n=>\nnet.(*pipe).Write at pipe.go\n=>\nmosn.io/layotto/components/rpc/invoker/mosn/channel.(*httpChannel).Do at httpchannel.go\nfunc (h *httpChannel) Do(req *rpc.RPCRequest) (*rpc.RPCResponse, error) {\n    ...\n    // \u63a5\u4e0a\u8ff00x04\u9636\u6bb5\uff0cmosn \u6570\u636e\u8fd4\u56de\u540e\uff0c\u4ece hstate \u8bfb\u53d6 readloop \u534f\u7a0b\u4ece mosn \u8fd4\u56de\u7684\u6570\u636e\n    if err = httpResp.Read(bufio.NewReader(hstate.reader)); err != nil {\n        hstate.close()\n        h.pool.Put(conn, true)\n        return nil, common.Error(common.UnavailebleCode, err.Error())\n    }\n    h.pool.Put(conn, false)\n\n    // \u83b7\u53d6 fasthttp \u7684\u6570\u636e\u90e8\u5206\uff0c\u89e3\u6790\u72b6\u6001\u7801\uff0c\u5931\u8d25\u8fd4\u56de\u9519\u8bef\u4fe1\u606f\u548c\u72b6\u6001\u7801\n    body := httpResp.Body()\n    if httpResp.StatusCode() != http.StatusOK {\n        return nil, common.Errorf(common.UnavailebleCode, "http response code %d, body: %s", httpResp.StatusCode(), string(body))\n    }\n    \n    // 6. \u5c06\u7ed3\u679c\u8f6c\u6362\u4e3a rpc.RPCResponse \u8fd4\u56de\n    rpcResp := &rpc.RPCResponse{\n        ContentType: string(httpResp.Header.ContentType()),\n        Data:        body,\n        Header:      map[string][]string{},\n    }\n    httpResp.Header.VisitAll(func(key, value []byte) {\n        rpcResp.Header[string(key)] = []string{string(value)}\n    })\n    return rpcResp, nil\n'})}),"\n",(0,o.jsx)(n.h3,{id:"0x09-grpc-sever-processed-data-frames-returned-to-clients",children:"0x09 Grpc Sever processed data frames returned to clients"}),"\n",(0,o.jsx)(n.p,{children:"Grpc does not write data directly to connections, but uses a systray loop to fetch frames from a cache structure and write them back to the client, as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'google.golang.org/grpc/internal/transport.NewServerTransport at http2_server.go\nfunc NewServerTransport(conn net.Conn, config *ServerConfig) (_ ServerTransport, err error) {\n    ...\n    // \u534f\u7a0b\u5f02\u6b65loop\u5faa\u73af\n    go func() {\n        t.loopy = newLoopyWriter(serverSide, t.framer, t.controlBuf, t.bdpEst)\n        t.loopy.ssGoAwayHandler = t.outgoingGoAwayHandler\n        if err := t.loopy.run(); err != nil {\n            if logger.V(logLevel) {\n                logger.Errorf("transport: loopyWriter.run returning. Err: %v", err)\n            }\n        }\n        t.conn.Close()\n        t.controlBuf.finish()\n        close(t.writerDone)\n    }()\n    go t.keepalive()\n    return t, nil\n}\n=>\ngoogle.golang.org/grpc/internal/transport.(*loopyWriter).run at controlbuf.go\n=>\ngoogle.golang.org/grpc/internal/transport.(*bufWriter).Flush at http_util.go\n=>\nmosn.io/mosn/pkg/filter/network/grpc.(*Connection).Write at conn.go\n=>\nmosn.io/mosn/pkg/network.(*connection).Write at connection.go\n=>\nmosn.io/mosn/pkg/network.(*connection).writeDirectly at connection.go\n=>\nmosn.io/mosn/pkg/network.(*connection).doWrite at connection.go\n'})}),"\n",(0,o.jsx)(n.h3,{id:"0x10-dubbo-go-sample-customer-received-response",children:"0x10 dubbo-go-sample customer received response"}),"\n",(0,o.jsx)(n.p,{children:"The transmission of data from 0x01 above will be blocked in the client grpc bottom reading, and Layotto returns data from some of the processing layers above to enable ClientBottom Read IO, as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"google.golang.org/grpc.(*ClientCon). Invoke at call.go\n=>\ngoogle.golang.org/grpc.(*ClientCon). Invoke at call.go\n=>\ngoogle.golang.org/grpc.(*clientStream). RecvMsg at stream. o\n=>\ngoogle.golang.org/grpc.(*clientStream).withRetry at stream.go\n=>\ngoogle.golang.org/grpc.(*csAtempt.recvMsg at stream.go\n=>\ngoogle.golang.org/grpc.recvAndDecompress at rpc_util. o\n=>\ngoogle.golang.org/grpc.recv at rpc_util.go\n=>\ngoogle.golang.org/grpc.(*parser).recvMsg at rpc_util.go\n=>\ngoogle.golang.org/grpc.(*csAttempt).recvMsg at stream. o\nfunc (p *parser) recvMsg(maxReceiveMessageSize int) (pf payloadFormat, msg []byte, err error) LO\n    if _, err := p. .Read(p.header[:]); err != nil {\n        return 0, nil, err\n    }\n    ...\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Last returned data\uff1a"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{"jsonrpc": "2.0", "id":9527, "result":{"id":"113", "name":"Moorse", "age":30,"time":703394193,"sex":"MAN"}}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(n.p,{children:["The Layotto RPC process involves knowledge related to GRPC, Dapr, Mosn and others, and the overall process is lengthy, although it is clearer and simpler simply to see Layotto for Mosn an abstract lightweight RPC framework and is more innovative and useful for further study.Here Layotto RPC requests are analyzed and time-limited without some more comprehensive and in-depth profiles, such as defects, welcome contact\uff1a",(0,o.jsx)(n.a,{href:"mailto:rayo.wangzl@gmail.com.It",children:"rayo.wangzl@gmail.com.It"})," is also hoped that there will be greater participation in source analysis and open source communities, learning together and making progress together."]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>i});var o=r(6540);const t={},a=o.createContext(t);function s(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);