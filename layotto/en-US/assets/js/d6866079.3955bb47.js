"use strict";(self.webpackChunklayotto_docusaurus=self.webpackChunklayotto_docusaurus||[]).push([[1617],{3786:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=n(4848),i=n(8453);const o={},a="Layotto Source Parsing \u2014 WebAssembly",s={permalink:"/layotto/en-US/blog/code/webassembly",editUrl:"https://github.com/mosn/layotto/edit/main/docs/i18n/en-US/docusaurus-plugin-content-blog/code/webassembly/index.md",source:"@site/i18n/en-US/docusaurus-plugin-content-blog/code/webassembly/index.md",title:"Layotto Source Parsing \u2014 WebAssembly",description:"This paper mainly analyses the relevant implementation and application of Layotto Middle WASM.",date:"2024-07-10T10:04:20.000Z",tags:[],readingTime:16.615,hasTruncateMarker:!1,authors:[],frontMatter:{},unlisted:!1,prevItem:{title:"Source parsing layotto startup process",permalink:"/layotto/en-US/blog/code/start_process/start_process"}},l={authorsImageUrls:[]},c=[{value:"General description",id:"general-description",level:2},{value:"Source analysis",id:"source-analysis",level:2},{value:"Frame INIT",id:"frame-init",level:3},{value:"Workflow",id:"workflow",level:3},{value:"FaaS Mode",id:"faas-mode",level:3},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:3}];function u(e){const t={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsx)(t.p,{children:"This paper mainly analyses the relevant implementation and application of Layotto Middle WASM."}),"\n",(0,r.jsxs)(t.p,{children:["by\uff1a",(0,r.jsx)(t.a,{href:"https://github.com/rayowang",children:"Wang Zhilong"})," | 18 May 2022"]}),"\n"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#overview",children:"overview"})}),"\n",(0,r.jsxs)(t.li,{children:["[source analysis](#source analysis)","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"[Frame INIT](#Frame INIT)"}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#workflow",children:"workflow"})}),"\n",(0,r.jsx)(t.li,{children:"[FaaSmode](#FaaS mode)"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#summary",children:"summary"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"general-description",children:"General description"}),"\n",(0,r.jsxs)(t.p,{children:["WebAssemly Abbreviations WASM, a portable, small and loaded binary format operating in sandboxing implementation environment, was originally designed to achieve high-performance applications in web browsers, benefiting from its good segregation and security, multilingual support, cool-start fast flexibility and agility and application to embed other applications for better expansion, and obviously we can embed it into Layotto.Layotto supports loading compiled WASM files and interacting with the Target WASM API via proxy_abi_version_0_2_0;\nother Layotto also supports loading and running WASM carrier functions and supports interfaces between Function and access to infrastructure; and Layotto communities are also exploring the compilation of components into WASM modules to increase segregation between modules.This article uses the Layotto official ",(0,r.jsx)(t.a,{href:"https://mosn.io/layotto/docs/start/wasm/start",children:"quickstart"})," example of accessing redis as an example to analyze WebAssemly in Layotto Related implementation and application."]}),"\n",(0,r.jsx)(t.h2,{id:"source-analysis",children:"Source analysis"}),"\n",(0,r.jsx)(t.p,{children:"Note\uff1ais based on commit hash\uff1af1cf350a52b5a1a0b3788a31681007a056e332ef"}),"\n",(0,r.jsx)(t.h3,{id:"frame-init",children:"Frame INIT"}),"\n",(0,r.jsx)(t.p,{children:"As the bottom layer of Layotto is Mosn, the WASM extension framework is also the WASM extension framework that reuses Mosn, as shown in figure 1 Layotto & Mosn WASM framework [1]."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://gw.alipayobjects.com/mdn/rms_5891a1/afts/img/A*jz4BSJmVQ3gAAAAAAAAAAAAAARQnAQ",alt:"mosn_wasm_ext_framework_module"})}),"\n",(0,r.jsx)("center",{children:"Figure 1 Layotto & Mosn WASM framework "}),"\n",(0,r.jsx)(t.p,{children:"Among them, Manager is responsible for managing and dynamically updating WASM plugins;VM for managing WASM virtual machines, modules and instances;ABI serves as the application binary interface to provide an external interface [2]."}),"\n",(0,r.jsxs)(t.p,{children:["Here a brief review of the following concepts\uff1a",(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.a,{href:"https://github.com/proxy-wasm",children:"Proxy-Wasm"})," \uff1aWebAssembly for Proxies (ABI specification) is an unrelated ABI standard that defines how proxy and WASM modules interact [3] in functions and callbacks.\n",(0,r.jsx)(t.a,{href:"https://github.com/tetratelabs/proxy-wasm-go-sdk",children:"proxy-wasm-go-sdk"})," \uff1adefines the interface of function access to system resources and infrastructure services based on ",(0,r.jsx)(t.a,{href:"https://github.com/proxy-wasm/spec",children:"proxy-wasm/spec"})," which brings together the Runtime API to increase access to infrastructure.",(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.a,{href:"https://github.com/mosn/proxy-wasm-go-host",children:"proxy-wasm-go-host"})," WebAssembly for Proxies (GoLang host implementation)\uff1aProxy-Wasm golang implementation to implement Runtime ABI logic in Layotto.",(0,r.jsx)(t.br,{}),"\n","VM: Virtual Machine Virtual machine. The Runtime types are wasmtime, wasmer, V8, Lucet, WAMR, and wasm3"]}),"\n",(0,r.jsxs)(t.p,{children:["1, see first the configuration of stream filter in ",(0,r.jsx)(t.a,{href:"https://mosn.io/layotto/#/start/waste/start",children:"quickstart\u4f8b\u5b50"})," as follows, two WASM plugins can be seen, using waste VM to start a separate instance with configuration\uff1a below"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-json",children:' "stream_filters": [\n            LO\n              "type": "Layotto",\n              "config": API\n                "Function1": LOs\n                  "name": "function1", // Plugin name\n                  "instance_num": 1, // Number of sandbox instances\n                  "vm_config": LO\n                    "engine": "waste", // Virtual Machine Type Runtime Type\n                    "path": "demo/faas/code/golang/client/function_1. asm" /waste file path\n                  }\n                },\n                "Function2": LO\n                  "name": "function2", // Plugin name\n                  "instance_num": 1, // Number of sandbox instances\n                  "vm_config": LO\n                    "engine": "waste", // Virtual Machine Type Runtime Type\n                    "path": "demo/faas/code/golang/server/function_2. asm" /wasm file path\n                  }\n                }\n              }\n            }\n]\n'})}),"\n",(0,r.jsx)(t.p,{children:"The primary logic in the configuration above is to receive HTTP requests, then call function2 through ABI, and return function2 as detailed below in code\uff1a"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'func (Ctx *pHeaders) OnHttpRequestBody(bodySize int, endOfStream bool) types.Action Led\n\t/1. get request body\n\tbody, err := proxywasm. etHttpRequestBody(0, bodySize)\n\tif err != nil L/\n\t\tproxywasm.LogErrorf("GetHttpRequestBody failed: %v", err)\n\t\treturn types. ctionPause\n\t}\n\n\t/2. parse request param\n\tbookName, err := getQueryParam(string(body), "name")\n\tif err != nil Led\n\t\tproxywasm. ogErrorf("param not found: %v", err)\n\t\treturns types. ctionPause\n\t}\n\n\t/3. Request function2 through ABI\n\tinventories, err := proxywasm. nvokeService("id_2", "", bookName)\n\tif err != nil LO\n\t\tproxywasm.Logrorf("invoke service failed: %v", err)\n\t\treturn types. ctionPause\n\t}\n\n\t/4. return result\n\tproxywasm. ppendHttpResponseBody([]byte ("There are " + inventories + " inventories for " + bookName + ".")\n\treturn types.ActionContinue\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"Function2 Primary logic is to receive HTTP requests, then call redisis through ABI and return to redis, as shown below in code\uff1a"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'func (Ctx *pHeaders) OnHttpRequestBody(bodySize int, endOfStream bool) types.Action 6\n\t//1. get requested body\n\tbody, err := proxywasm.GetHttpRequestBody(0, bodySize)\n\tif err != nil Led\n\t\tproxywasm. ogErrorf("GetHttpRequestBody failed: %v", err)\n\t\treturns types.ActionPause\n\t}\n\tbookName:= string(body)\n\n\t/ 2. get request state from redis by specific key through ABI\n\tinventories, err := proxywastem. etState("redis", bookName)\n\tif err != nil LO\n\t\tproxywasm.LogErrorf("GetState failed: %v", err)\n\t\treturns types. ctionPause\n\t}\n\n\t/ 3. return result\n\tproxywasm.AppendHttpResponseBody([]byte(inventories))\n\treturn types.ActionContinue\n}\n'})}),"\n",(0,r.jsxs)(t.ol,{start:"2",children:["\n",(0,r.jsx)(t.li,{children:"The Manager component of the Frame 1 WASM is initialized at Mosn filter Init stage as shown below in code\uff1a"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'// Create a proxy factory for WasmFilter\nfunc createProxyWasmFilterFactory(confs map[string]interface{}) (api.StreamFilterChainFactory, error) {\n\tfactory := &FilterConfigFactory{\n\t\tconfig:        make([]*filterConfigItem, 0, len(confs)),\n\t\tRootContextID: 1,\n\t\tplugins:       make(map[string]*WasmPlugin),\n\t\trouter:        &Router{routes: make(map[string]*Group)},\n\t}\n\n\tfor configID, confIf := range confs {\n\t\tconf, ok := confIf.(map[string]interface{})\n\t\tif !ok {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] createProxyWasmFilterFactory config not a map, configID: %s", configID)\n\t\t\treturn nil, errors.New("config not a map")\n\t\t}\n\t\t// Parse the wasm filter configuration\n\t\tconfig, err := parseFilterConfigItem(conf)\n\t\tif err != nil {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] createProxyWasmFilterFactory fail to parse config, configID: %s, err: %v", configID, err)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar pluginName string\n\t\tif config.FromWasmPlugin == "" {\n\t\t\tpluginName = utils.GenerateUUID()\n            \n\t\t\t// The WASM plug-in configuration is initialized according to the stream filter configuration. VmConfig is vm_config, and InstanceNum is instance_num\n\t\t\tv2Config := v2.WasmPluginConfig{\n\t\t\t\tPluginName:  pluginName,\n\t\t\t\tVmConfig:    config.VmConfig,\n\t\t\t\tInstanceNum: config.InstanceNum,\n\t\t\t}\n            \n\t\t\t// The WasmManager instance manages the configuration of all plug-ins in a unified manner by managing the PluginWrapper object, providing the ability to add, delete, check and modify. Continue 3\n\t\t\terr = wasm.GetWasmManager().AddOrUpdateWasm(v2Config)\n\t\t\tif err != nil {\n\t\t\t\tconfig.PluginName = pluginName\n\t\t\t\taddWatchFile(config, factory)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\taddWatchFile(config, factory)\n\t\t} else {\n\t\t\tpluginName = config.FromWasmPlugin\n\t\t}\n\t\tconfig.PluginName = pluginName\n\n\t\t// PluginWrapper wraps the plug-in and configuration in AddOrUpdateWasm above to complete the initialization, which is pulled from sync.Map according to the plug-in name to manage and register the PluginHandler\n\t\tpw := wasm.GetWasmManager().GetWasmPluginWrapperByName(pluginName)\n\t\tif pw == nil {\n\t\t\treturn nil, errors.New("plugin not found")\n\t\t}\n\n\t\tconfig.VmConfig = pw.GetConfig().VmConfig\n\t\tfactory.config = append(factory.config, config)\n\n\t\twasmPlugin := &WasmPlugin{\n\t\t\tpluginName:    config.PluginName,\n\t\t\tplugin:        pw.GetPlugin(),\n\t\t\trootContextID: config.RootContextID,\n\t\t\tconfig:        config,\n\t\t}\n\t\tfactory.plugins[config.PluginName] = wasmPlugin\n\t\t// Register PluginHandler to provide extended callback capabilities for the plug-in\'s life cycle, such as the plug-in starting OnPluginStart and updating OnConfigUpdate. Continue 4\n\t\tpw.RegisterPluginHandler(factory)\n\t}\n\n\treturn factory, nil\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"3 Corresponding to Figure 1 WASM frame, NewWasmPlugin, for creating initialization of the WASM plugin, where VM, Module and Instance refer to virtual machines, modules and instances in WASM, as shown below in code\uff1a"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'func NewWasmPlugin(wasmConfig v2.WasmPluginConfig) (types.WasmPlugin, error) {\n\t// check instance num\n\tinstanceNum := wasmConfig.InstanceNum\n\tif instanceNum <= 0 {\n\t\tinstanceNum = runtime.NumCPU()\n\t}\n\n\twasmConfig.InstanceNum = instanceNum\n\n\t// Get the wasmer compilation and execution engine according to the configuration\n\tvm := GetWasmEngine(wasmConfig.VmConfig.Engine)\n\tif vm == nil {\n\t\tlog.DefaultLogger.Errorf("[wasm][plugin] NewWasmPlugin fail to get wasm engine: %v", wasmConfig.VmConfig.Engine)\n\t\treturn nil, ErrEngineNotFound\n\t}\n\n\t// load wasm bytes\n\tvar wasmBytes []byte\n\tif wasmConfig.VmConfig.Path != "" {\n\t\twasmBytes = loadWasmBytesFromPath(wasmConfig.VmConfig.Path)\n\t} else {\n\t\twasmBytes = loadWasmBytesFromUrl(wasmConfig.VmConfig.Url)\n\t}\n\n\tif len(wasmBytes) == 0 {\n\t\tlog.DefaultLogger.Errorf("[wasm][plugin] NewWasmPlugin fail to load wasm bytes, config: %v", wasmConfig)\n\t\treturn nil, ErrWasmBytesLoad\n\t}\n\n\tmd5Bytes := md5.Sum(wasmBytes)\n\tnewMd5 := hex.EncodeToString(md5Bytes[:])\n\tif wasmConfig.VmConfig.Md5 == "" {\n\t\twasmConfig.VmConfig.Md5 = newMd5\n\t} else if newMd5 != wasmConfig.VmConfig.Md5 {\n\t\tlog.DefaultLogger.Errorf("[wasm][plugin] NewWasmPlugin the hash(MD5) of wasm bytes is incorrect, config: %v, real hash: %s",\n\t\t\twasmConfig, newMd5)\n\t\treturn nil, ErrWasmBytesIncorrect\n\t}\n\n\t// Create the WASM module, which is the stateless binary code that has been compiled\n\tmodule := vm.NewModule(wasmBytes)\n\tif module == nil {\n\t\tlog.DefaultLogger.Errorf("[wasm][plugin] NewWasmPlugin fail to create module, config: %v", wasmConfig)\n\t\treturn nil, ErrModuleCreate\n\t}\n\n\tplugin := &wasmPluginImpl{\n\t\tconfig:    wasmConfig,\n\t\tvm:        vm,\n\t\twasmBytes: wasmBytes,\n\t\tmodule:    module,\n\t}\n\n\tplugin.SetCpuLimit(wasmConfig.VmConfig.Cpu)\n\tplugin.SetMemLimit(wasmConfig.VmConfig.Mem)\n\n\t// Contains module and runtime state to create instance, notable is that here will call proxywasm. RegisterImports registered users realize the Imports of function, Examples include proxy_invoke_service and proxy_get_state\nactual := plugin.EnsureInstanceNum(wasmConfig.InstanceNum)\n\tif actual == 0 {\n\t\tlog.DefaultLogger.Errorf("[wasm][plugin] NewWasmPlugin fail to ensure instance num, want: %v got 0", instanceNum)\n\t\treturn nil, ErrInstanceCreate\n\t}\n\n\treturn plugin, nil\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"Corresponding to ABI components in Figure 1 WASM frames, the OnPluginStart method calls proxy-wasm-go-host corresponding to ABI Exports and Imports etc."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'// Execute the plugin of FilterConfigFactory\nfunc (f *FilterConfigFactory) OnPluginStart(plugin types.WasmPlugin) {\n\tplugin.Exec(func(instance types.WasmInstance) bool {\n\t\twasmPlugin, ok := f.plugins[plugin.PluginName()]\n\t\tif !ok {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] createProxyWasmFilterFactory fail to get wasm plugin, PluginName: %s",\n\t\t\t\tplugin.PluginName())\n\t\t\treturn true\n\t\t}\n        \n\t\t// \u83b7\u53d6 proxy_abi_version_0_2_0 \u7248\u672c\u7684\u4e0e WASM \u4ea4\u4e92\u7684 API\n\t\ta := abi.GetABI(instance, AbiV2)\n\t\ta.SetABIImports(f)\n\t\texports := a.GetABIExports().(Exports)\n\t\tf.LayottoHandler.Instance = instance\n\n\t\tinstance.Lock(a)\n\t\tdefer instance.Unlock()\n\n\t\t// Use the exports function proxy_get_id (which corresponds to the GetID function in the WASM plug-in) to get the ID of WASM\n\t\tid, err := exports.ProxyGetID()\n\t\tif err != nil {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] createProxyWasmFilterFactory fail to get wasm id, PluginName: %s, err: %v",\n\t\t\t\tplugin.PluginName(), err)\n\t\t\treturn true\n\t\t}\n\t\t// If you register the ID and the corresponding plug-in in the route, the route can be performed using the key-value pair in the http Header. For example, \'id:id_1\' is routed to Function1 based on id_1 \n\t\tf.router.RegisterRoute(id, wasmPlugin)\n\n\t\t// The root context is created by proxy_on_context_create when the first plug-in is loaded with the given root ID and persists for the entire life of the virtual machine until proxy_on_delete is deleted\n               // It is worth noting that the first plug-in here refers to a use case where multiple loosely bound plug-ins (accessed via the SDK using the Root ID to the Root Context) share data within the same configured virtual machine [4]\n\t\terr = exports.ProxyOnContextCreate(f.RootContextID, 0)\n\t\tif err != nil {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] OnPluginStart fail to create root context id, err: %v", err)\n\t\t\treturn true\n\t\t}\n\n\t\tvmConfigSize := 0\n\t\tif vmConfigBytes := wasmPlugin.GetVmConfig(); vmConfigBytes != nil {\n\t\t\tvmConfigSize = vmConfigBytes.Len()\n\t\t}\n\n\t\t// VM is called when the plug-in is started with the startup\n\t\t_, err = exports.ProxyOnVmStart(f.RootContextID, int32(vmConfigSize))\n\t\tif err != nil {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] OnPluginStart fail to create root context id, err: %v", err)\n\t\t\treturn true\n\t\t}\n\n\t\tpluginConfigSize := 0\n\t\tif pluginConfigBytes := wasmPlugin.GetPluginConfig(); pluginConfigBytes != nil {\n\t\t\tpluginConfigSize = pluginConfigBytes.Len()\n\t\t}\n\n\t\t// Called when the plug-in loads or reloads its configuration\n\t\t_, err = exports.ProxyOnConfigure(f.RootContextID, int32(pluginConfigSize))\n\t\tif err != nil {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] OnPluginStart fail to create root context id, err: %v", err)\n\t\t\treturn true\n\t\t}\n\n\t\treturn true\n\t})\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"workflow",children:"Workflow"}),"\n",(0,r.jsxs)(t.p,{children:["The workflow for Layotto Middle WASM is broadly as shown in figure 2 Layotto & Mosn WASM workflow, where the configuration is largely covered by the initial elements above, with a focus on the request processing.\n",(0,r.jsx)(t.img,{src:"https://gw.alipayobjects.com/mdn/rms_5891a1/afts/img/A*XTDeRq0alYsAAAAAAAAAAAAAARQnAQ",alt:"mosn_wasm_ext_framework_workflow"})]}),"\n",(0,r.jsx)("center",{children:"Figure 2 Layotto & Mosn WAS Workflow "}),"\n",(0,r.jsx)(t.p,{children:"By Layotto underneath Mosn, as a workpool schedule, implement the OnReceive method of StreamFilterChain to Wasm StreamFilter in proxy downstream, as configured and detailed in code\uff1a below"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'func (f *Filter) OnReceive(ctx context.Context, headers api.HeaderMap, buf buffer.IoBuffer, trailers api.HeaderMap) api.StreamFilterStatus {\n\t// Gets the id of the WASM plug-in\n\tid, ok := headers.Get("id")\n\tif !ok {\n\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive call ProxyOnRequestHeaders no id in headers")\n\t\treturn api.StreamFilterStop\n\t}\n    \n\t// Obtain the WASM plug-in from the router based on its id\n\twasmPlugin, err := f.router.GetRandomPluginByID(id)\n\tif err != nil {\n\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive call ProxyOnRequestHeaders id, err: %v", err)\n\t\treturn api.StreamFilterStop\n\t}\n\tf.pluginUsed = wasmPlugin\n\n\tplugin := wasmPlugin.plugin\n\t// Obtain an instance of WasmInstance\n\tinstance := plugin.GetInstance()\n\tf.instance = instance\n\tf.LayottoHandler.Instance = instance\n\n\t// The ABI consists of Exports and Imports, through which users interact with the WASM extension\n\tpluginABI := abi.GetABI(instance, AbiV2)\n\tif pluginABI == nil {\n\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive fail to get instance abi")\n\t\tplugin.ReleaseInstance(instance)\n\t\treturn api.StreamFilterStop\n\t}\n\t// Set the Imports section. The import section is provided by the user. The execution of the virtual machine depends on some of the capabilities provided by the host Layotto, such as obtaining request information, which are provided by the user through the import section and invoked by the WASM extension\n\tpluginABI.SetABIImports(f)\n\n\t// The Exports section is provided by the WASM plug-in and can be called directly by the user to wake up the WASM virtual machine and execute the corresponding WASM plug-in code in the virtual machine\n\texports := pluginABI.GetABIExports().(Exports)\n\tf.exports = exports\n\t\n\tinstance.Lock(pluginABI)\n\tdefer instance.Unlock()\n\t\n\t// Create the current plug-in context according to rootContextID and contextID\n\terr = exports.ProxyOnContextCreate(f.contextID, wasmPlugin.rootContextID)\n\tif err != nil {\n\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] NewFilter fail to create context id: %v, rootContextID: %v, err: %v",\n\t\t\tf.contextID, wasmPlugin.rootContextID, err)\n\t\treturn api.StreamFilterStop\n\t}\n\n\tendOfStream := 1\n\tif (buf != nil && buf.Len() > 0) || trailers != nil {\n\t\tendOfStream = 0\n\t}\n\n\t// Call proxy-wasm-go-host, encoding the request header in the format specified by the specification\n\taction, err := exports.ProxyOnRequestHeaders(f.contextID, int32(headerMapSize(headers)), int32(endOfStream))\n\tif err != nil || action != proxywasm.ActionContinue {\n\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive call ProxyOnRequestHeaders err: %v", err)\n\t\treturn api.StreamFilterStop\n\t}\n\n\tendOfStream = 1\n\tif trailers != nil {\n\t\tendOfStream = 0\n\t}\n\n\tif buf == nil {\n\t\targ, _ := variable.GetString(ctx, types.VarHttpRequestArg)\n\t\tf.requestBuffer = buffer.NewIoBufferString(arg)\n\t} else {\n\t\tf.requestBuffer = buf\n\t}\n\n\tif f.requestBuffer != nil && f.requestBuffer.Len() > 0 {\n\t\t// Call proxy-wasm-go-host, encoding the request body in the format specified by the specification\n\t\taction, err = exports.ProxyOnRequestBody(f.contextID, int32(f.requestBuffer.Len()), int32(endOfStream))\n\t\tif err != nil || action != proxywasm.ActionContinue {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive call ProxyOnRequestBody err: %v", err)\n\t\t\treturn api.StreamFilterStop\n\t\t}\n\t}\n\n\tif trailers != nil {\n        // Call proxy-wasm-go-host, encoding the request tail in the format specified by the specification\n\t\taction, err = exports.ProxyOnRequestTrailers(f.contextID, int32(headerMapSize(trailers)))\n\t\tif err != nil || action != proxywasm.ActionContinue {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive call ProxyOnRequestTrailers err: %v", err)\n\t\t\treturn api.StreamFilterStop\n\t\t}\n\t}\n\n\treturn api.StreamFilterContinue\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"2, proxy-wasm-go-host encode Mosn requests for triplets into the specified format and call Proxy-Wasm ABI equivalent interface in Proxy_on_request_headers and call the WASMER virtual machine to pass the request information to the WASM plugin."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"func (a *ABIContext) CallWasmFunction (functionName string, args ..interface{}) (interface{}, Action, error) um\n\tff, err := a.Instance. eExportsFunc(functionName)\n\tif err != nil {\n\t\treturn nil, ActionContinue, err\n\t}\n\n\t// Call waste virtual machine (Github.com/wasmerio/wasmer-go/wasmer.(*Function).Call at function.go)\n\tres, err := ff. all(args....)\n\tif err != nil L/\n\t\ta.Instance.HandleError(err)\n\t\treturn nil, ActionContinue, err\n\t}\n\n\t// if we have sync call, e. HttpCall, then unlocked the waste instance and wait until it resp\n\taction := a.Imports.Wait()\n\n\treturn res, action, nil\n}\n"})}),"\n",(0,r.jsxs)(t.ol,{start:"3",children:["\n",(0,r.jsxs)(t.li,{children:["The WASMER virtual machine is processed to call specific functions of the WASM plug-in, such as the OnHttpRequestBody function in the example\n// function, ",(0,r.jsx)(t.em,{children:':= instance.Exports.GetFunction("exported_function")\n// nativeFunction = function.Native()\n//'})," = nativeFunction(1, 2, 3)\n// Native converts Function to a native Go function that can be called"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"func (self *Function) Native() NativeFunction {\n\t...\n\tself.lazyNative = func(receivedParameters ...interface{}) (interface{}, error) {\n\t\tnumberOfReceivedParameters := len(receivedParameters)\n\t\tnumberOfExpectedParameters := len(expectedParameters)\n\t\t...\n\t\tresults := C.wasm_val_vec_t{}\n\t\tC.wasm_val_vec_new_uninitialized(&results, C.size_t(len(ty.Results())))\n\t\tdefer C.wasm_val_vec_delete(&results)\n\n\t\targuments := C.wasm_val_vec_t{}\n\t\tdefer C.wasm_val_vec_delete(&arguments)\n\n\t\tif numberOfReceivedParameters > 0 {\n\t\t\tC.wasm_val_vec_new(&arguments, C.size_t(numberOfReceivedParameters), (*C.wasm_val_t)(unsafe.Pointer(&allArguments[0])))\n\t\t}\n\n\t\t// Call functions inside the WASM plug-in\n\t\ttrap := C.wasm_func_call(self.inner(), &arguments, &results)\n\n\t\truntime.KeepAlive(arguments)\n\t\truntime.KeepAlive(results)\n\t\t...\n\t}\n\n\treturn self.lazyNative\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"4, proxy-wasm-go-sdk converts the requested data from the normative format to a user-friendly format and then calls the user extension code.Proxy-wasm-go-sdk, based on proxy-waste/spec implementation, defines the interface between function access to system resources and infrastructure services, and builds on this integration of the Runtime API, adding ABI to infrastructure access."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'// function1The main logic is to receive the HTTP request, call function2 using the ABI, and return the function2 result. The code is as follows\nfunc (ctx *httpHeaders) OnHttpRequestBody(bodySize int, endOfStream bool) types.Action {\n\t//1. get request body\n\tbody, err := proxywasm.GetHttpRequestBody(0, bodySize)\n\tif err != nil {\n\t\tproxywasm.LogErrorf("GetHttpRequestBody failed: %v", err)\n\t\treturn types.ActionPause\n\t}\n\n\t//2. parse request param\n\tbookName, err := getQueryParam(string(body), "name")\n\tif err != nil {\n\t\tproxywasm.LogErrorf("param not found: %v", err)\n\t\treturn types.ActionPause\n\t}\n\n\t//3. request function2 through ABI\n\tinventories, err := proxywasm.InvokeService("id_2", "", bookName)\n\tif err != nil {\n\t\tproxywasm.LogErrorf("invoke service failed: %v", err)\n\t\treturn types.ActionPause\n\t}\n\n\t//4. return result\n\tproxywasm.AppendHttpResponseBody([]byte("There are " + inventories + " inventories for " + bookName + "."))\n\treturn types.ActionContinue\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"5, WASM plugin is registered at RegisterFunc initialization. For example, Function1 RPC calls Proxy InvokeService,Function2 to get ProxyGetState specified in Redis as shown below in\uff1a"}),"\n",(0,r.jsx)(t.p,{children:"Function1 Call Function2, Proxy InvokeService for Imports function proxy_invoke_service through the Proxy InvokeService"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"func ProxyInvokeService(instance common). asmInstance, idPtr int32, idSize int32, methodPtr int32, methodPtr int32, paramPtr int32, resultPtr int32, resultSize int32) int32 56\n\tid, err := instance. etMemory(uint64(idPtr), uint64(idSize))\n\tif err != nil LO\n\t\treturnWasmResultInvalidMemoryAcces.Int32()\n\t}\n\n\tmethod, err := instance. etMemory(uint64 (methodPtr), uint64 (methodSize))\n\tif err != nil LO\n\t\treturnWasmResultInvalidMemoryAccess. nt32()\n\t}\n\n\tparam, err := instance.GetMemory(uint64 (paramPtr), uint64 (paramSize))\n\tif err != nil Fe\n\t\treturnn WasmResultInvalidMemoryAccess. nt32()\n\t}\n\n\tctx:= getImportHandler(instance)\n    \n\t// Laytto rpc calls\n\tret, res := ctx. nvokeService(string(id), string(param))\n\tif res != WasmResultOk 6\n\t\treturn res.Int32()\n\n\n\treturn copyIntoInstance(instance, ret, resultPtr, resultSize).Int32()\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Function2 Get Redis via ProxyGetState to specify key Valye, ProxyGetState for Imports function proxy_get_state"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"func ProxyGetState(instance common.WasmInstance, storeNamePtr int32, storeNameSize int32, keyPtr int32, valuePtr int32, valueSize int32) int32 Fe\n\tstoreName, err := instance. etMemory(uint64 (storeNamePtr), uint64 (storeNameSize))\n\tif err != nil LO\n\t\treturnWasmResultInvalidMemoryAccess.Int32()\n\t}\n\n\tkey, err := instance. etMemory(uint64(keyPtr), uint64(keySize))\n\tif err != nil LO\n\t\treturnWasmResultInvalidMemoryAccess.Int32()\n\t}\n\n\tctx := getImportHandler(instance)\n\n\tret, res := ctx. etState(string(storeName), string(key))\n\tif res != WasmResultOk 6\n\t\treturn res.Int32()\n\t}\n\n\treturn copyIntoInstance(instance, ret, valuePtr, valueSize). Int32()\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["More than the Layotto rpc process is briefly described as the implementation of [5]by two virtual connections using the Dapr API and underneath Mosn, see previous order articles [Layotto source parsing \u2014 processing RPC requests] (",(0,r.jsx)(t.a,{href:"https://mosn.io/layotto/#/blog/code/layotto-rpc/index",children:"https://mosn.io/layotto/#/blog/code/layotto-rpc/index"}),"), where data from Redis can be obtained directly from Dapr State code and is not developed here."]}),"\n",(0,r.jsx)(t.h3,{id:"faas-mode",children:"FaaS Mode"}),"\n",(0,r.jsx)(t.p,{children:"Look back back to the WASM features\uff1abytes code that match the machine code; guarantee good segregation and security in the sandbox; compile cross-platforms, easily distributed, and load running; have lightweight and multilingual flexibilities and seem naturally suitable for FaaS."}),"\n",(0,r.jsx)(t.p,{children:"So Layotto also explores support for WASM FaaS mode by loading and running WASM carrier functions and supporting interfaces and access to infrastructure between Function.Since the core logic of loading the WASM has not changed, except that there is a difference between usage and deployment methods and those described above, the Layotto load part of the ASM logic is not redundant."}),"\n",(0,r.jsx)(t.p,{children:'In addition to the Wasm-Proxy implementation, the core logic of the FaaS mode is to manage the *.wasm package and Kubernetes excellent structuring capabilities by expanding Containerd to multiple-run plugins containerd-shim-layotto-v2 [6]and using this "piercing wire" ingenuity to use Docker mirror capability. Specific structures and workflows can be found in Figure 3 Layotto FaaS Workflow.'}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://gw.alipayobjects.com/mdn/rms_5891a1/afts/img/A*XWmNT6-7FoEAAAAAAAAAAAAAARQnAQ",alt:"layotto_faas_workflow"})}),"\n",(0,r.jsx)("center",{children:"Figure 3 Layotto FaaS Workflow "}),"\n",(0,r.jsx)(t.p,{children:"Here a simple look at the master function of containerd-shim-layotto-v2. It can be seen that shim.Run runs the WASM as io.containerd.layotto.v2, and runtime_type of the containerd plugins.crimerd.runtimes corresponding to the plugin.When creating a Pod, you specify runtimeClassName: layotto in yaml speed, and eventually kubelet will load and run them when cric-plugin calls containerd-shim-layotto-v2 is running."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'func main() {\n\tstartLayotto()\n\t// \u89e3\u6790\u8f93\u5165\u53c2\u6570\uff0c\u521d\u59cb\u5316\u8fd0\u884c\u65f6\u73af\u5883\uff0c\u8c03\u7528 wasm.New \u5b9e\u4f8b\u5316 service \u5bf9\u8c61 \n\tshim.Run("io.containerd.layotto.v2", wasm.New)\n}\n\nfunc startLayotto() {\n\tconn, err := net.Dial("tcp", "localhost:2045")\n\tif err == nil {\n\t\tconn.Close()\n\t\treturn\n\t}\n\n\tcmd := exec.Command("layotto", "start", "-c", "/home/docker/config.json")\n\tcmd.Start()\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(t.p,{children:['Layotto WebAssemly involves more basic WASM knowledge, but it is understandable that the examples are shallow deeper and gradual.At the end of the spectrum, the ASM technology can be seen to have been applied to many fields such as Web-Front, Serverlessness, Game Scene, Edge Computing, Service Grids, or even to the Docker parent Solomon Hykes recently said: "If the WASM technology is available in 2008, I will not be able to do the Docker" (later added that\uff1aDocker will not be replaced and will walk side by side with WASM) The ASM seems to be becoming lighter and better performing cloud-origin technology and being applied to more areas after the VM and Container, while believing that there will be more use scenes and users in Mosn community push and in Layotto continue exploration, here Layotto WebAssemly relevant source code analysis has been completed. Given time and length, some more comprehensive and in-depth profiles have not been carried out, and if there are flaws, welcome fingers, contact\uff1arayo. ',(0,r.jsx)(t.a,{href:"mailto:angzl@gmail.com",children:"angzl@gmail.com"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"references",children:"References"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["[1] ",(0,r.jsx)(t.a,{href:"https://mosn.io/blog/posts/mosn-wasm-framework/",children:"WebAssembly practice in MOSN"})]}),"\n",(0,r.jsxs)(t.li,{children:["[2] ",(0,r.jsx)(t.a,{href:"https://github.com/mosn/mosn/pull/1589",children:"feature: WASM plugin framework"})]}),"\n",(0,r.jsxs)(t.li,{children:["[3] ",(0,r.jsx)(t.a,{href:"https://github.com/proxy-wasm/spec",children:"WebAssembly for Proxies (ABI Spec)"})]}),"\n",(0,r.jsxs)(t.li,{children:["[4] ",(0,r.jsx)(t.a,{href:"https://techhenzy.com/proxy-webassembly-archive/",children:"Proxy WebAssembly Architecture"})]}),"\n",(0,r.jsxs)(t.li,{children:["[5] ",(0,r.jsx)(t.a,{href:"https://mosn.io/layotto/#/blog/code/layotto-rpc/index",children:"Layotto source parse \u2014 processing RPC requests"})]}),"\n",(0,r.jsxs)(t.li,{children:["[6] ",(0,r.jsx)(t.a,{href:"https://www.soft.tech/blog/the-next-fuve-years-of-cloud-native-runtime/",children:"Cloud native runtime for the next five years"})]}),"\n"]})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var r=n(6540);const i={},o=r.createContext(i);function a(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);