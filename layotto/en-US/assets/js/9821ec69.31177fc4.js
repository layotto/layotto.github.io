"use strict";(self.webpackChunklayotto_docusaurus=self.webpackChunklayotto_docusaurus||[]).push([[4608],{7707:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=t(4848),r=t(8453);const s={},o="Sequencer API",a={id:"building_blocks/sequencer/reference",title:"Sequencer API",description:"What is Sequencer API",source:"@site/i18n/en-US/docusaurus-plugin-content-docs/current/building_blocks/sequencer/reference.md",sourceDirName:"building_blocks/sequencer",slug:"/building_blocks/sequencer/reference",permalink:"/layotto/en-US/docs/building_blocks/sequencer/reference",draft:!1,unlisted:!1,editUrl:"https://github.com/mosn/layotto/edit/main/building_blocks/sequencer/reference.md",tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"State API",permalink:"/layotto/en-US/docs/building_blocks/state/reference"},next:{title:"Distributed Lock API",permalink:"/layotto/en-US/docs/building_blocks/lock/reference"}},c={},l=[{value:"What is Sequencer API",id:"what-is-sequencer-api",level:2},{value:"When to use Sequencer API",id:"when-to-use-sequencer-api",level:2},{value:"When you need to generate a globally unique id",id:"when-you-need-to-generate-a-globally-unique-id",level:3},{value:"And you want the generated id increases automatically",id:"and-you-want-the-generated-id-increases-automatically",level:3},{value:"How to use Sequencer API",id:"how-to-use-sequencer-api",level:2},{value:"Get next unique id",id:"get-next-unique-id",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"sequencer-api",children:"Sequencer API"}),"\n",(0,i.jsx)(n.h2,{id:"what-is-sequencer-api",children:"What is Sequencer API"}),"\n",(0,i.jsx)(n.p,{children:"The Sequencer API is used to generate distributed unique, self-incrementing IDs."}),"\n",(0,i.jsx)(n.p,{children:"The Sequencer API supports the declaration of demand for self-increment, including trend increase (WEAK) and strictly global increment (STRONG)"}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-sequencer-api",children:"When to use Sequencer API"}),"\n",(0,i.jsx)(n.h3,{id:"when-you-need-to-generate-a-globally-unique-id",children:"When you need to generate a globally unique id"}),"\n",(0,i.jsx)(n.p,{children:"Q: When do I need to generate a globally unique id?"}),"\n",(0,i.jsx)(n.p,{children:"A: When db does not automatically generate it for you. for example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'After you do mysql sharding yourself, mysql will never automatically generate a globally unique id for you again, but you do need a globally unique business id (for example, "order id")'}),"\n",(0,i.jsx)(n.li,{children:"The request does not go to the db, for example, a traceId is generated when the request reaches the backend servers."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"and-you-want-the-generated-id-increases-automatically",children:"And you want the generated id increases automatically"}),"\n",(0,i.jsx)(n.p,{children:"Specifically, there are many types of requirement:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["No increment is required. UUID fits this situation, although the disadvantage is that it is relatively long. ",(0,i.jsx)(n.strong,{children:"If this is the case, it is recommended to use UUID to solve it by yourself, no need to call this API"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:'"The trend is increasing". It means you do not need a strictly global increase, just want "in most cases it is increasing". In this case, it is recommended to use this API'}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Q: What scenarios will I need an increasing trend?"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For b+ tree type db (such as MYSQL), the primary key with increasing trend can make better use of cache (cache friendly)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"When you want to use the id to sort and query the latest data. For example, the requirement is to check the latest 100 messages, and the developer does not want to add a timestamp field and build an index on it. If the id itself is incremented, then the latest 100 messages can be sorted by id directly:"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"select * from message order by message-id limit 100\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is very common when using nosql, because it is difficult for nosql to index on another timestamp field"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Global monotonically increasing"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When you want the generated id incremental without any regression, it is recommended to use this API"}),"\n",(0,i.jsx)(n.h2,{id:"how-to-use-sequencer-api",children:"How to use Sequencer API"}),"\n",(0,i.jsxs)(n.p,{children:["You can call the Sequencer API through grpc. The API is defined in ",(0,i.jsx)(n.a,{href:"https://github.com/mosn/layotto/blob/main/spec/proto/runtime/v1/runtime.proto",children:"runtime.proto"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Layotto client sdk encapsulates the logic of grpc calling. For an example of using sdk to call Sequencer API, please refer to ",(0,i.jsx)(n.a,{href:"/layotto/en-US/docs/start/sequencer/start",children:"Quick Start: Use Sequencer API"})]}),"\n",(0,i.jsxs)(n.p,{children:["The components need to be configured before use. For detailed configuration options, see ",(0,i.jsx)(n.a,{href:"/layotto/en-US/docs/component_specs/sequencer/common",children:"Sequencer component document"})]}),"\n",(0,i.jsx)(n.h3,{id:"get-next-unique-id",children:"Get next unique id"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// Sequencer API\n// Get next unique id with some auto-increment guarantee\nrpc GetNextId(GetNextIdRequest)returns (GetNextIdResponse) {}\n  \nmessage GetNextIdRequest {\n  // Required. Name of sequencer storage\n  string store_name = 1;\n  // Required. key is the identifier of a sequencer namespace,e.g. "order_table".\n  string key = 2;\n  // (optional) SequencerOptions configures requirements for auto-increment guarantee\n  SequencerOptions options = 3;\n  // (optional) The metadata which will be sent to the component.\n  map<string, string> metadata = 4;\n}\n\n// SequencerOptions configures requirements for auto-increment guarantee\nmessage SequencerOptions {\n  // requirements for auto-increment guarantee\n  enum AutoIncrement {\n    // (default) WEAK means a "best effort" incrementing service.But there is no strict guarantee of global monotonically increasing.\n    //The next id is "probably" greater than current id.\n    WEAK = 0;\n    // STRONG means a strict guarantee of global monotonically increasing.\n    //The next id "must" be greater than current id.\n    STRONG = 1;\n  }\n\n  AutoIncrement increment = 1;\n}\n  \nmessage GetNextIdResponse{\n  // The next unique id\n  int64 next_id = 1;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To avoid inconsistencies between the documentation and the code, please refer to ",(0,i.jsx)(n.a,{href:"https://github.com/mosn/layotto/blob/main/spec/proto/runtime/v1/runtime.proto",children:"proto file"})," for detailed input parameters and return values"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);