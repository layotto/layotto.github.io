"use strict";(self.webpackChunklayotto_docusaurus=self.webpackChunklayotto_docusaurus||[]).push([[6246],{7284:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var o=n(4848),i=n(8453);const r={},a="Source Parse 4 Layer Traffic Governance, tcp traffic dump",s={permalink:"/en-US/blog/tcpcopy_code_analyze",editUrl:"https://github.com/mosn/layotto/edit/main//i18n/en-US/docusaurus-plugin-content-blog/tcpcopy_code_analyze.md",source:"@site/i18n/en-US/docusaurus-plugin-content-blog/tcpcopy_code_analyze.md",title:"Source Parse 4 Layer Traffic Governance, tcp traffic dump",description:"Author profile\uff1a",date:"2024-07-05T06:04:47.000Z",tags:[],readingTime:3.34,hasTruncateMarker:!1,authors:[],frontMatter:{},unlisted:!1,prevItem:{title:"Ant Cloud Native Apps Exploring and Practice - ArchiSummit",permalink:"/en-US/blog/exploration-and-practice-of-antcloud-native-application-runtime-archsummit-shanghai"},nextItem:{title:"MOSN subproject Layotto\uff1aopens the service grid + new chapter when app runs",permalink:"/en-US/blog/mosn-subproject-layotto-opening-a-new-chapter-in-service-grid-application-runtime"}},c={authorsImageUrls:[]},l=[{value:"Overview",id:"overview",level:2},{value:"Prerequisite\uff1a",id:"prerequisite",level:2},{value:"Source analysis",id:"source-analysis",level:2},{value:"Code in\uff1a tcpcopy CODE",id:"code-in-tcpcopy-code",level:3},{value:"model.go analysis",id:"modelgo-analysis",level:3},{value:"persistence.go analysis",id:"persistencego-analysis",level:3},{value:"tcpcopy.go analysis",id:"tcpcopygo-analysis",level:3}];function p(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Author profile\uff1a\nGiggon, is an open source community lover committed to embracing open sources."}),"\n",(0,o.jsx)(t.p,{children:"Writing on: April 26, 2022"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(t.p,{children:"The purpose of this document is to analyze the implementation of tcp traffic dump"}),"\n",(0,o.jsx)(t.h2,{id:"prerequisite",children:"Prerequisite\uff1a"}),"\n",(0,o.jsx)(t.p,{children:"Document content refers to the following version of the code"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.a,{href:"https://github.com/mosn/layotto",children:"https://github.com/mosn/layotto"})}),"\n",(0,o.jsx)(t.p,{children:"Layotto 0e97e97e970dc504e0298017bd956d2841c44c0810b (main)"}),"\n",(0,o.jsx)(t.h2,{id:"source-analysis",children:"Source analysis"}),"\n",(0,o.jsxs)(t.h3,{id:"code-in-tcpcopy-code",children:["Code in\uff1a ",(0,o.jsx)(t.a,{href:"https://github.com/mosn/layotto/tree/main/pkg/filter/network/tcpcopy",children:"tcpcopy CODE"})]}),"\n",(0,o.jsx)(t.h3,{id:"modelgo-analysis",children:"model.go analysis"}),"\n",(0,o.jsx)(t.p,{children:"This is the core class of tcpcopy's configuration objects"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'Type DumpConfig struct {-\n\tSwitch `json:"twitch"` // dump switch. Values\uff1a\'ON\' or \'OFF\'\n\tInterval int `json:"interval" //dump sampling interval Unit: Second\n\tDuration int `json:"duration"// Single Sampling Cycle Unit: Second\n\tCpuMaxate float64 `json:"cpu_max_rate"\\/ cpu Maximum usage The ump feature will stop\n\tMemMaxRate float64 `json:"mem_max_rate"` // mem maximum usage. When this threshold is exceeded, The ump feature will stop\n}\n\nType DumpUpadDynamic Architect 6\n\tUnique_sample_windowing string// Specify sample window\n\tBusinessType _type. usinessType // Business Type\n\tPort string // Port\n\tBinary_flow_data []byte// binary data\n\tPortrait_data string // User uploaded data\n}\n'})}),"\n",(0,o.jsx)(t.h3,{id:"persistencego-analysis",children:"persistence.go analysis"}),"\n",(0,o.jsx)(t.p,{children:"This is the dump persistent core processing class of tcpcopy"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'// This method is called in OnData in tcpcopy.go\nfunc IsPersistence() bool {\n\t// \u5224\u65ad dump \u5f00\u5173\u662f\u5426\u5f00\u542f\n\tif !strategy.DumpSwitch {\n\t\tif log.DefaultLogger.GetLogLevel() >= log.DEBUG {\n\t\t\tlog.DefaultLogger.Debugf("%s the dump switch is %t", model.LogDumpKey, strategy.DumpSwitch)\n\t\t}\n\t\treturn false\n\t}\n\n\t// Check whether it is in the sampling window\n\tif atomic.LoadInt32(&strategy.DumpSampleFlag) == 0 {\n\t\tif log.DefaultLogger.GetLogLevel() >= log.DEBUG {\n\t\t\tlog.DefaultLogger.Debugf("%s the dump sample flag is %d", model.LogDumpKey, strategy.DumpSampleFlag)\n\t\t}\n\t\treturn false\n\t}\n\n\t// Check whether the dump function is stopped. Obtain the system load and check whether the processor and memory exceeds the threshold of the tcpcopy. If yes, stop the dump function.\n\tif !strategy.IsAvaliable() {\n\t\tif log.DefaultLogger.GetLogLevel() >= log.DEBUG {\n\t\t\tlog.DefaultLogger.Debugf("%s the system usages are beyond max rate.", model.LogDumpKey)\n\t\t}\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Persist data based on configuration information\nfunc persistence(config *model.DumpUploadDynamicConfig) {\n\t// 1.Persisting binary data\n\tif config.Binary_flow_data != nil && config.Port != "" {\n\t\tif GetTcpcopyLogger().GetLogLevel() >= log.INFO {\n\t\t\tGetTcpcopyLogger().Infof("[%s][%s]% x", config.Unique_sample_window, config.Port, config.Binary_flow_data)\n\t\t}\n\t}\n\tif config.Portrait_data != "" && config.BusinessType != "" {\n\t\t// 2. Persisting Binary data Persisting user-defined data\n\t\tif GetPortraitDataLogger().GetLogLevel() >= log.INFO {\n\t\t\tGetPortraitDataLogger().Infof("[%s][%s][%s]%s", config.Unique_sample_window, config.BusinessType, config.Port, config.Portrait_data)\n\t\t}\n\n\t\t// 3. Changes in configuration information in incrementally persistent memory\n\t\tbuf, err := configmanager.DumpJSON()\n\t\tif err != nil {\n\t\t\tif log.DefaultLogger.GetLogLevel() >= log.DEBUG {\n\t\t\t\tlog.DefaultLogger.Debugf("[dump] Failed to load mosn config mem.")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\t// 3.1. dump if the data changes\n\t\ttmpMd5ValueOfMemDump := common.CalculateMd5ForBytes(buf)\n\t\tmemLogger := GetMemLogger()\n\t\tif tmpMd5ValueOfMemDump != md5ValueOfMemDump ||\n\t\t\t(tmpMd5ValueOfMemDump == md5ValueOfMemDump && common.GetFileSize(getMemConfDumpFilePath()) <= 0) {\n\t\t\tmd5ValueOfMemDump = tmpMd5ValueOfMemDump\n\t\t\tif memLogger.GetLogLevel() >= log.INFO {\n\t\t\t\tmemLogger.Infof("[%s]%s", config.Unique_sample_window, buf)\n\t\t\t}\n\t\t} else {\n\t\t\tif memLogger.GetLogLevel() >= log.INFO {\n\t\t\t\tmemLogger.Infof("[%s]%+v", config.Unique_sample_window, incrementLog)\n\t\t\t}\n\t\t}\n\t}\n}\n'})}),"\n",(0,o.jsx)(t.h3,{id:"tcpcopygo-analysis",children:"tcpcopy.go analysis"}),"\n",(0,o.jsx)(t.p,{children:"This is the core class of tcpcopy."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-go",children:'// Sign up to NetWork \nfunc init() with MFA\n\tapi. egisterNetwork("tcpcopy", CreateTccopyFactory)\n}\n\n// returns tcpcopy Factory\nfunc CreateTccopyFactory(cfg map[string]interface{}) (api. etworkFilterChainFactory, error) LO\n\ttcpConfig := &config{}\n\t// dump policy transition to static configuration\n\tif stg, ok := cfg["strategy"]; ok {\n\t...\n\t}\n\t//TODO excerpt some other fields\n\treturn &tcpcopyFactoryLU\n\t\tcfg: tcpConfig,\n\t}, nil\n}\n\n// for pkg/configmanager/parser. o Call to add or update Network filter factory\nfunc (f *tcpcopyFactory) Init(param interface{}) error error 56\n\t// Set listening address and port configuration\n\t...\n\treturn nil\n}\n\n// implements the OnData Interface of ReadFilter, processing\nfunc (f *tcpcopyFactory) OnData(data types.IoBuffer) (res api. ilterStatus) online\n\t// Determines whether the current requested data requires sampling dump \n\tif !persiste.Isistence() {\n\t\treturn api.Continue\n\t}\n\n\t// Asynchronous sample dump\n\tconfig := model.NewDumpUpadDynamic Config(strategy. umpSampleUuid, "", f.cfg.port, data.Bytes(), "")\n\tpersistence.GetDumpWorkPoolInstance().Schedule(config)\n\treturn api.Continue\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"Finally, we look back at the overall process progress:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Starting from the initialization function init() of tccopy.go to CreateGRPCServerFilterFactory Incoming CreateTcpcopyFactory."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Mosn created a filter chain (code position",(0,o.jsx)(t.a,{href:"https://github.com/mosn/mosn/tree/master/pkg/filter/network/proxy/factory.go",children:"factory.go"}),") by circulating CreateFilterChain to add all filters to the chain structure, including tccopy."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"When the traffic passes through mosn will enter the tcpcopy.go OnData method for tcpcopump logical processing."}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var o=n(6540);const i={},r=o.createContext(i);function a(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);